{"cells":[{"cell_type":"markdown","source":["# Convex first"],"metadata":{"id":"QiOC3IqFEEAF"}},{"cell_type":"code","source":["!pip install fancyimpute\n","import numpy as np\n","import pandas as pd\n","import matplotlib.pyplot as plt\n","from fancyimpute import SoftImpute # Make sure this is installed\n","from sklearn.model_selection import train_test_split\n","import time\n","import warnings\n","from sklearn.exceptions import ConvergenceWarning # To potentially catch solver warnings\n","from google.colab import drive # Uncomment if using Colab\n","drive.mount(\"/content/drive\", force_remount=True)\n","DRIVE_MOUNTED = True\n","# --- Configuration ---\n","# Use your correct path\n","DATA_PATH = \"/content/drive/MyDrive/ml-1m/ratings.dat\"\n","TEST_SIZE = 0.2\n","np.random.seed(42)\n","\n","# --- Load MovieLens 1M Data ---\n","try:\n","    ratings = pd.read_csv(\n","        DATA_PATH, sep=\"::\", engine='python',\n","        names=[\"UserID\", \"MovieID\", \"Rating\", \"Timestamp\"]\n","    ).drop(columns=['Timestamp'])\n","except FileNotFoundError:\n","    print(f\"ERROR: Ratings file not found at {DATA_PATH}\")\n","    exit() # Or raise Exception(...)\n","\n","# Adjust index to be 0-based if necessary (check max IDs vs shape later)\n","ratings['UserID'] -= 1\n","ratings['MovieID'] -= 1\n","num_users = ratings['UserID'].max() + 1\n","num_movies = ratings['MovieID'].max() + 1\n","\n","print(f\"Dataset loaded: {num_users} users, {num_movies} movies, {len(ratings)} ratings.\")\n","\n","# --- Train/Validation Split ---\n","train, val = train_test_split(ratings, test_size=TEST_SIZE, random_state=42)\n","\n","def ratings_to_matrix(df, shape):\n","    mat = np.full(shape, np.nan, dtype=np.float64) # Use float for NaNs\n","    # Ensure indices are within bounds\n","    valid_rows = df['UserID'] < shape[0]\n","    valid_cols = df['MovieID'] < shape[1]\n","    valid_df = df[valid_rows & valid_cols]\n","    if len(valid_df) < len(df):\n","        print(f\"Warning: Filtered out {len(df) - len(valid_df)} ratings with out-of-bounds UserID/MovieID.\")\n","    # Use .loc for potentially safer assignment if indices are not guaranteed contiguous\n","    mat[valid_df['UserID'].values, valid_df['MovieID'].values] = valid_df['Rating'].values\n","    return mat\n","\n","# Ensure shape matches max IDs + 1\n","matrix_shape = (num_users, num_movies)\n","train_matrix = ratings_to_matrix(train, matrix_shape)\n","val_matrix = ratings_to_matrix(val, matrix_shape)\n","\n","train_mask = ~np.isnan(train_matrix)\n","val_mask = ~np.isnan(val_matrix)\n","print(f\"Training matrix shape: {train_matrix.shape}, Known values: {train_mask.sum()}\")\n","print(f\"Validation matrix shape: {val_matrix.shape}, Known values: {val_mask.sum()}\")\n","\n","\n","# --- SoftImpute Run (Corrected) ---\n","total_max_iters = 50 # Set the total number of internal iterations desired\n","shrinkage_value = 20.0 # Regularization parameter lambda\n","\n","# Prepare the input matrix with NaNs\n","X_incomplete = np.where(train_mask, train_matrix, np.nan)\n","\n","# Initialize the solver ONCE with total iterations\n","# Set verbose=True to see internal iteration progress printed by fancyimpute\n","solver = SoftImpute(\n","    shrinkage_value=shrinkage_value,\n","    max_iters=total_max_iters,\n","    verbose=True # Set to True to see internal progress\n",")\n","\n","print(f\"\\nRunning SoftImpute with max_iters={total_max_iters}...\")\n","\n","start_time = time.time()\n","\n","# Suppress FutureWarning during the fit/transform process\n","# Also suppress potential ConvergenceWarning from the underlying solver if it doesn't converge fully\n","with warnings.catch_warnings():\n","    warnings.simplefilter(\"ignore\", category=FutureWarning)\n","    warnings.simplefilter(\"ignore\", category=ConvergenceWarning)\n","    try:\n","        # Call fit_transform ONCE\n","        X_filled = solver.fit_transform(X_incomplete)\n","        elapsed = time.time() - start_time\n","        print(f\"\\nSoftImpute completed in {elapsed:.2f}s\")\n","\n","        # --- Calculate final RMSE ---\n","        # Training RMSE isn't very informative (should be ~0)\n","        if train_mask.sum() > 0:\n","            # Use a small epsilon if calculating log later, otherwise not strictly needed\n","            train_rmse = np.sqrt(np.mean((train_matrix[train_mask] - X_filled[train_mask])**2))\n","        else:\n","            train_rmse = np.nan\n","\n","        # Validation RMSE is the key metric\n","        if val_mask.sum() > 0:\n","            val_rmse = np.sqrt(np.mean((val_matrix[val_mask] - X_filled[val_mask])**2))\n","        else:\n","            val_rmse = np.nan\n","\n","        print(f\"Final Train RMSE: {train_rmse:.6f} (Note: Expected near 0 if observed values preserved)\")\n","        print(f\"Final Val RMSE:   {val_rmse:.6f}\")\n","\n","    except Exception as e:\n","        elapsed = time.time() - start_time\n","        print(f\"\\nERROR during SoftImpute fit_transform after {elapsed:.2f}s: {e}\")\n","        # Handle error appropriately (e.g., print traceback)\n","        import traceback\n","        traceback.print_exc()"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"957jpxAEHsAc","outputId":"b71f7a68-677a-4b13-d037-47d68268fc61","executionInfo":{"status":"ok","timestamp":1746527715153,"user_tz":240,"elapsed":915398,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}}},"execution_count":1,"outputs":[{"output_type":"stream","name":"stdout","text":["Collecting fancyimpute\n","  Downloading fancyimpute-0.7.0.tar.gz (25 kB)\n","  Installing build dependencies ... \u001b[?25l\u001b[?25hdone\n","  Getting requirements to build wheel ... \u001b[?25l\u001b[?25hdone\n","  Preparing metadata (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","Collecting knnimpute>=0.1.0 (from fancyimpute)\n","  Downloading knnimpute-0.1.0.tar.gz (8.3 kB)\n","  Installing build dependencies ... \u001b[?25l\u001b[?25hdone\n","  Getting requirements to build wheel ... \u001b[?25l\u001b[?25hdone\n","  Preparing metadata (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","Requirement already satisfied: scikit-learn>=0.24.2 in /usr/local/lib/python3.11/dist-packages (from fancyimpute) (1.6.1)\n","Collecting cvxpy (from fancyimpute)\n","  Downloading cvxpy-1.6.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (9.3 kB)\n","Collecting cvxopt (from fancyimpute)\n","  Downloading cvxopt-1.3.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (1.3 kB)\n","Requirement already satisfied: pytest in /usr/local/lib/python3.11/dist-packages (from fancyimpute) (8.3.5)\n","Collecting nose (from fancyimpute)\n","  Downloading nose-1.3.7-py3-none-any.whl.metadata (1.7 kB)\n","Requirement already satisfied: six in /usr/local/lib/python3.11/dist-packages (from knnimpute>=0.1.0->fancyimpute) (1.17.0)\n","Requirement already satisfied: numpy>=1.10 in /usr/local/lib/python3.11/dist-packages (from knnimpute>=0.1.0->fancyimpute) (2.0.2)\n","Requirement already satisfied: scipy>=1.6.0 in /usr/local/lib/python3.11/dist-packages (from scikit-learn>=0.24.2->fancyimpute) (1.15.2)\n","Requirement already satisfied: joblib>=1.2.0 in /usr/local/lib/python3.11/dist-packages (from scikit-learn>=0.24.2->fancyimpute) (1.4.2)\n","Requirement already satisfied: threadpoolctl>=3.1.0 in /usr/local/lib/python3.11/dist-packages (from scikit-learn>=0.24.2->fancyimpute) (3.6.0)\n","Collecting osqp>=0.6.2 (from cvxpy->fancyimpute)\n","  Downloading osqp-1.0.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.1 kB)\n","Collecting clarabel>=0.5.0 (from cvxpy->fancyimpute)\n","  Downloading clarabel-0.10.0-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (4.8 kB)\n","Collecting scs>=3.2.4.post1 (from cvxpy->fancyimpute)\n","  Downloading scs-3.2.7.post2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.1 kB)\n","Requirement already satisfied: iniconfig in /usr/local/lib/python3.11/dist-packages (from pytest->fancyimpute) (2.1.0)\n","Requirement already satisfied: packaging in /usr/local/lib/python3.11/dist-packages (from pytest->fancyimpute) (25.0)\n","Requirement already satisfied: pluggy<2,>=1.5 in /usr/local/lib/python3.11/dist-packages (from pytest->fancyimpute) (1.5.0)\n","Requirement already satisfied: jinja2 in /usr/local/lib/python3.11/dist-packages (from osqp>=0.6.2->cvxpy->fancyimpute) (3.1.6)\n","Requirement already satisfied: setuptools in /usr/local/lib/python3.11/dist-packages (from osqp>=0.6.2->cvxpy->fancyimpute) (75.2.0)\n","Requirement already satisfied: MarkupSafe>=2.0 in /usr/local/lib/python3.11/dist-packages (from jinja2->osqp>=0.6.2->cvxpy->fancyimpute) (3.0.2)\n","Downloading cvxopt-1.3.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.6 MB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m13.6/13.6 MB\u001b[0m \u001b[31m91.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hDownloading cvxpy-1.6.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (1.2 MB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.2/1.2 MB\u001b[0m \u001b[31m22.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hDownloading nose-1.3.7-py3-none-any.whl (154 kB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m154.7/154.7 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hDownloading clarabel-0.10.0-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (1.0 MB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.0/1.0 MB\u001b[0m \u001b[31m22.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hDownloading osqp-1.0.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (344 kB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m344.1/344.1 kB\u001b[0m \u001b[31m7.6 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hDownloading scs-3.2.7.post2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (10.4 MB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m10.4/10.4 MB\u001b[0m \u001b[31m61.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hBuilding wheels for collected packages: fancyimpute, knnimpute\n","  Building wheel for fancyimpute (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","  Created wheel for fancyimpute: filename=fancyimpute-0.7.0-py3-none-any.whl size=29966 sha256=904110f7f468cb667c25a27313bd01547f8e5df2207e495c10d6173cb9e2079b\n","  Stored in directory: /root/.cache/pip/wheels/1a/f3/a1/f7f10b5ae2c2459398762a3fcf4ac18c325311c7e3163d5a15\n","  Building wheel for knnimpute (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","  Created wheel for knnimpute: filename=knnimpute-0.1.0-py3-none-any.whl size=11131 sha256=f5d0bda773aab91a829dd7b0099b242fd08dd8050d3165bb620c5b28a5bc9d36\n","  Stored in directory: /root/.cache/pip/wheels/ea/e8/e0/79872972161e54486517ae507f94b2c7cea27fb7ef793bd415\n","Successfully built fancyimpute knnimpute\n","Installing collected packages: nose, knnimpute, cvxopt, scs, osqp, clarabel, cvxpy, fancyimpute\n","Successfully installed clarabel-0.10.0 cvxopt-1.3.2 cvxpy-1.6.5 fancyimpute-0.7.0 knnimpute-0.1.0 nose-1.3.7 osqp-1.0.3 scs-3.2.7.post2\n","Mounted at /content/drive\n","Dataset loaded: 6040 users, 3952 movies, 1000209 ratings.\n","Training matrix shape: (6040, 3952), Known values: 800167\n","Validation matrix shape: (6040, 3952), Known values: 200042\n","\n","Running SoftImpute with max_iters=50...\n","[SoftImpute] Max Singular Value of X_init = 1514.386816\n","[SoftImpute] Iter 1: observed MAE=0.749473 rank=1821\n","[SoftImpute] Iter 2: observed MAE=0.711531 rank=1513\n","[SoftImpute] Iter 3: observed MAE=0.683646 rank=1317\n","[SoftImpute] Iter 4: observed MAE=0.662084 rank=1177\n","[SoftImpute] Iter 5: observed MAE=0.644946 rank=1068\n","[SoftImpute] Iter 6: observed MAE=0.631090 rank=984\n","[SoftImpute] Iter 7: observed MAE=0.619724 rank=915\n","[SoftImpute] Iter 8: observed MAE=0.610378 rank=854\n","[SoftImpute] Iter 9: observed MAE=0.602463 rank=805\n","[SoftImpute] Iter 10: observed MAE=0.595761 rank=762\n","[SoftImpute] Iter 11: observed MAE=0.590059 rank=723\n","[SoftImpute] Iter 12: observed MAE=0.585136 rank=691\n","[SoftImpute] Iter 13: observed MAE=0.580869 rank=661\n","[SoftImpute] Iter 14: observed MAE=0.577217 rank=634\n","[SoftImpute] Iter 15: observed MAE=0.574000 rank=611\n","[SoftImpute] Iter 16: observed MAE=0.571144 rank=589\n","[SoftImpute] Iter 17: observed MAE=0.568604 rank=569\n","[SoftImpute] Iter 18: observed MAE=0.566346 rank=551\n","[SoftImpute] Iter 19: observed MAE=0.564353 rank=535\n","[SoftImpute] Iter 20: observed MAE=0.562578 rank=521\n","[SoftImpute] Iter 21: observed MAE=0.560997 rank=506\n","[SoftImpute] Iter 22: observed MAE=0.559529 rank=494\n","[SoftImpute] Iter 23: observed MAE=0.558200 rank=480\n","[SoftImpute] Iter 24: observed MAE=0.556998 rank=470\n","[SoftImpute] Iter 25: observed MAE=0.555880 rank=459\n","[SoftImpute] Iter 26: observed MAE=0.554876 rank=450\n","[SoftImpute] Iter 27: observed MAE=0.553911 rank=441\n","[SoftImpute] Iter 28: observed MAE=0.553057 rank=432\n","[SoftImpute] Iter 29: observed MAE=0.552258 rank=425\n","[SoftImpute] Iter 30: observed MAE=0.551494 rank=417\n","[SoftImpute] Iter 31: observed MAE=0.550778 rank=410\n","[SoftImpute] Iter 32: observed MAE=0.550117 rank=404\n","[SoftImpute] Iter 33: observed MAE=0.549492 rank=396\n","[SoftImpute] Iter 34: observed MAE=0.548900 rank=390\n","[SoftImpute] Iter 35: observed MAE=0.548341 rank=385\n","[SoftImpute] Iter 36: observed MAE=0.547799 rank=381\n","[SoftImpute] Iter 37: observed MAE=0.547306 rank=375\n","[SoftImpute] Iter 38: observed MAE=0.546842 rank=371\n","[SoftImpute] Iter 39: observed MAE=0.546400 rank=367\n","[SoftImpute] Iter 40: observed MAE=0.545970 rank=363\n","[SoftImpute] Iter 41: observed MAE=0.545577 rank=361\n","[SoftImpute] Iter 42: observed MAE=0.545189 rank=355\n","[SoftImpute] Iter 43: observed MAE=0.544808 rank=352\n","[SoftImpute] Iter 44: observed MAE=0.544432 rank=348\n","[SoftImpute] Iter 45: observed MAE=0.544075 rank=346\n","[SoftImpute] Iter 46: observed MAE=0.543729 rank=342\n","[SoftImpute] Iter 47: observed MAE=0.543396 rank=339\n","[SoftImpute] Iter 48: observed MAE=0.543060 rank=335\n","[SoftImpute] Iter 49: observed MAE=0.542741 rank=333\n","[SoftImpute] Iter 50: observed MAE=0.542440 rank=332\n","[SoftImpute] Stopped after iteration 50 for lambda=20.000000\n","\n","SoftImpute completed in 850.89s\n","Final Train RMSE: 0.000000 (Note: Expected near 0 if observed values preserved)\n","Final Val RMSE:   1.207558\n"]}]},{"cell_type":"code","source":["val_rmse = np.sqrt(np.nanmean((val_matrix[val_mask] - X_filled[val_mask])**2))\n","print(f\"Validation RMSE after iteration: {val_rmse:.4f}\")\n"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"U5ZI4e8BKx8S","executionInfo":{"status":"ok","timestamp":1746527715251,"user_tz":240,"elapsed":94,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}},"outputId":"cfa56896-2fbc-41e7-8e40-7fcd8c0a41aa"},"execution_count":2,"outputs":[{"output_type":"stream","name":"stdout","text":["Validation RMSE after iteration: 1.2076\n"]}]},{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import matplotlib.pyplot as plt\n","from fancyimpute import SoftImpute\n","from sklearn.model_selection import train_test_split\n","from sklearn.metrics import mean_squared_error\n","\n","# --- Load MovieLens 1M Data ---\n","DATA_PATH = \"/content/drive/MyDrive/ml-1m/ratings.dat\"\n","\n","ratings = pd.read_csv(\n","    DATA_PATH, sep=\"::\", engine='python',\n","    names=[\"UserID\", \"MovieID\", \"Rating\", \"Timestamp\"]\n",").drop(columns=['Timestamp'])\n","\n","# Adjust to zero-based indexing\n","ratings['UserID'] -= 1\n","ratings['MovieID'] -= 1\n","num_users = ratings['UserID'].max() + 1\n","num_movies = ratings['MovieID'].max() + 1\n","\n","# Train/Validation Split\n","train, val = train_test_split(ratings, test_size=0.2, random_state=42)\n","\n","# Convert ratings to matrices\n","def ratings_to_matrix(df, shape):\n","    mat = np.full(shape, np.nan)\n","    mat[df['UserID'], df['MovieID']] = df['Rating']\n","    return mat\n","\n","matrix_shape = (num_users, num_movies)\n","train_matrix = ratings_to_matrix(train, matrix_shape)\n","val_matrix = ratings_to_matrix(val, matrix_shape)\n","\n","train_mask = ~np.isnan(train_matrix)\n","val_mask = ~np.isnan(val_matrix)\n","\n","X_incomplete = np.where(train_mask, train_matrix, np.nan)\n","\n","# Hyperparameter ranges\n","shrinkage_values = [5, 10, 15, 20, 25]\n","max_iter_values = [30, 50, 75]\n","\n","# Track results\n","results = []\n","\n","for shrinkage in shrinkage_values:\n","    for max_iter in max_iter_values:\n","        print(f\"\\nRunning SoftImpute with λ={shrinkage}, max_iter={max_iter}\")\n","\n","        solver = SoftImpute(\n","            shrinkage_value=shrinkage,\n","            max_iters=max_iter,\n","            verbose=False\n","        )\n","\n","        X_filled = solver.fit_transform(X_incomplete)\n","\n","        val_preds = X_filled[val_mask]\n","        val_true = val_matrix[val_mask]\n","        val_rmse = np.sqrt(mean_squared_error(val_true, val_preds))\n","\n","        print(f\"Shrinkage: {shrinkage}, Max Iter: {max_iter}, Val RMSE: {val_rmse:.4f}\")\n","\n","        results.append({\n","            'shrinkage': shrinkage,\n","            'max_iter': max_iter,\n","            'val_rmse': val_rmse\n","        })\n","\n","# Visualization\n","plt.figure(figsize=(10, 6))\n","for shrinkage in shrinkage_values:\n","    rmse_values = [r['val_rmse'] for r in results if r['shrinkage'] == shrinkage]\n","    plt.plot(max_iter_values, rmse_values, marker='o', label=f'λ={shrinkage}')\n","\n","plt.xlabel('Max Iterations')\n","plt.ylabel('Validation RMSE')\n","plt.title('SoftImpute Hyperparameter Tuning on MovieLens 1M')\n","plt.grid(True)\n","plt.legend(title='Shrinkage λ')\n","plt.show()"],"metadata":{"id":"aCZb5gdf276R","executionInfo":{"status":"ok","timestamp":1746540938643,"user_tz":240,"elapsed":13223391,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}},"colab":{"base_uri":"https://localhost:8080/","height":1000},"outputId":"459ee248-31a0-4fc1-c051-e836266d0ccb"},"execution_count":3,"outputs":[{"output_type":"stream","name":"stdout","text":["\n","Running SoftImpute with λ=5, max_iter=30\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 5, Max Iter: 30, Val RMSE: 2.3969\n","\n","Running SoftImpute with λ=5, max_iter=50\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 5, Max Iter: 50, Val RMSE: 1.9878\n","\n","Running SoftImpute with λ=5, max_iter=75\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 5, Max Iter: 75, Val RMSE: 1.6971\n","\n","Running SoftImpute with λ=10, max_iter=30\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 10, Max Iter: 30, Val RMSE: 1.8390\n","\n","Running SoftImpute with λ=10, max_iter=50\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 10, Max Iter: 50, Val RMSE: 1.5101\n","\n","Running SoftImpute with λ=10, max_iter=75\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 10, Max Iter: 75, Val RMSE: 1.3161\n","\n","Running SoftImpute with λ=15, max_iter=30\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 15, Max Iter: 30, Val RMSE: 1.5617\n","\n","Running SoftImpute with λ=15, max_iter=50\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 15, Max Iter: 50, Val RMSE: 1.3091\n","\n","Running SoftImpute with λ=15, max_iter=75\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 15, Max Iter: 75, Val RMSE: 1.1693\n","\n","Running SoftImpute with λ=20, max_iter=30\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 20, Max Iter: 30, Val RMSE: 1.4064\n","\n","Running SoftImpute with λ=20, max_iter=50\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 20, Max Iter: 50, Val RMSE: 1.2076\n","\n","Running SoftImpute with λ=20, max_iter=75\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 20, Max Iter: 75, Val RMSE: 1.1012\n","\n","Running SoftImpute with λ=25, max_iter=30\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 25, Max Iter: 30, Val RMSE: 1.3169\n","\n","Running SoftImpute with λ=25, max_iter=50\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 25, Max Iter: 50, Val RMSE: 1.1575\n","\n","Running SoftImpute with λ=25, max_iter=75\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n","/usr/local/lib/python3.11/dist-packages/sklearn/utils/deprecation.py:151: FutureWarning: 'force_all_finite' was renamed to 'ensure_all_finite' in 1.6 and will be removed in 1.8.\n","  warnings.warn(\n"]},{"output_type":"stream","name":"stdout","text":["Shrinkage: 25, Max Iter: 75, Val RMSE: 1.0734\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1000x600 with 1 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAAA04AAAIjCAYAAAA0vUuxAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAA74JJREFUeJzs3Xd8FHX+x/HXbnpvpEAISSD0DiGAtCC9ii3SRe88OREV7PhTwIbtsGD3FJRiQVERBUFAKYIhQKjSSQGSUNIgIaTN748le8YESCANeD/vsY9jv/udmc9MZtf97Hc+3zEZhmEgIiIiIiIiF2Su7gBERERERERqOiVOIiIiIiIil6DESURERERE5BKUOImIiIiIiFyCEicREREREZFLUOIkIiIiIiJyCUqcRERERERELkGJk4iIiIiIyCUocRIREREREbkEJU4i14FXX32V+vXrY2NjQ5s2bao7HBGpIJGRkURGRlZ3GNeFcePGERISUt1hiEg1UuIkUsPs2LGD2267jeDgYBwdHQkMDKRPnz7MmjXrsta3fPlyHnvsMbp06cLs2bN58cUXOXbsGNOmTSM2NrZE/3HjxuHq6nqFe1H5fvrpJ6ZNm1bh6502bRomk4mTJ0+W+npISAiDBw+u8O1Kxfr999+ZNm0a6enplb6tuLg4TCZTmR5xcXGVHs+1pujY/fOf/yz19aeeesra50Lv2+oWGRlJixYtqjuMMvvyyy8ZPXo0DRs2xGQyXTA5nzNnjvXYr1u3rsTrhmEQFBSEyWTS56ZcE2yrOwAR+Z/ff/+dnj17Uq9ePe655x4CAgJITExk48aNvPnmm0ycOLHc61y1ahVms5mPP/4Ye3t7AGJiYpg+fTohISFX7QjUTz/9xDvvvFMpyZNc/X7//XemT5/OuHHj8PT0rNRt+fr6Mnfu3GJt//nPfzhy5Aivv/56ib4Vafny5RW6vprK0dGRb775hnfffdf6OVbk888/x9HRkZycnEqN4aOPPqKwsLBSt1FTvPfee2zevJkOHTpw6tSpS/Z3dHRkwYIFdO3atVj7b7/9xpEjR3BwcKisUEWqlBInkRrkhRdewMPDg02bNpX4snf8+PHLWufx48dxcnIq8WVDrk1ZWVm4uLhUybYKCwvJzc3F0dGxSrZXE2RnZ+Ps7FyszcXFhdGjRxdr++KLL0hLSyvRXtGul/d1//79Wbx4MUuXLuWmm26ytv/+++8cPnyYW2+9lW+++aZSY7Czs6vU9dckc+fOJTAwELPZXKaRsoEDB7Jw4ULeeustbG3/99VywYIFtG/fvsaOBIqUly7VE6lBDh48SPPmzUv9hdzPz6/Y8/z8fJ577jkaNGiAg4MDISEhTJkyhXPnzln7mEwmZs+eTVZWlvVyijlz5tChQwcA7rrrrmLtF1J0edqvv/5KeHg4Tk5OtGzZkl9//RWARYsW0bJlSxwdHWnfvj1bt24ttnzR5X+HDh2iX79+uLi4UKdOHZ599lkMw7D2+/XXXzGZTNb1Fim6FKooxnHjxvHOO+9Y97HoUaSwsJA33niD5s2b4+joiL+/P/feey9paWkX3MfLYRgGISEhxb7IFcnJycHDw4N777232L59+eWXTJkyhYCAAFxcXBg6dCiJiYkllv/jjz/o378/Hh4eODs706NHD9avX1+sT9Flhbt372bkyJF4eXlZf/Et6zEHeO2117jhhhvw8fHBycmJ9u3b8/XXX5eIyWQycf/99zN//nyaN2+Og4MDy5Ytu6x1LFy4kGbNmuHk5ETnzp3ZsWMHAB988AFhYWE4OjoSGRlZ6qVtlzo206ZN49FHHwUgNDS01Mvk5s2bR/v27XFycsLb25vhw4eX+DsUXV61efNmunfvjrOzM1OmTCkRT1mZTKZSR0hDQkIYN26c9XnR5U/r169n8uTJ+Pr64uLiws0338yJEydKxPjXy6iKzrOvvvqKF154gbp16+Lo6EivXr04cOBAiW2/88471K9fHycnJyIiIli7dm2Z66bK8hlUtH+DBw9m3bp1RERE4OjoSP369fnss88uuY0igYGBdO/enQULFhRrnz9/Pi1btrzgl/uFCxda/861atVi9OjRHD161Pr6a6+9hslkIj4+vsSyTz75JPb29tbPjdJqnCr6s2bp0qV069YNFxcX3NzcGDRoELt27SrWp+i9ffToUYYNG4arqyu+vr488sgjFBQUFOv7xRdf0L59e9zc3HB3d6dly5a8+eabl4wjKCgIs7nsXxFHjBjBqVOnWLFihbUtNzeXr7/+mpEjR5Z5PSI1nRInkRokODiYzZs3s3Pnzkv2/ec//8kzzzxDu3bteP311+nRowczZsxg+PDh1j5z586lW7duODg4MHfuXObOnUvTpk159tlnAfjXv/5lbe/evftFt3fgwAFGjhzJkCFDmDFjBmlpaQwZMoT58+czadIkRo8ezfTp0zl48CBRUVElLmkpKCigf//++Pv788orr9C+fXumTp3K1KlTy32c7r33Xvr06WPdx6LHX19/9NFH6dKlC2+++SZ33XUX8+fPp1+/fuTl5ZVpG6mpqZw8ebLE46/7ZTKZGD16NEuXLiU1NbXY8j/88AOZmZklRhxeeOEFfvzxRx5//HEeeOABVqxYQe/evTl79qy1z6pVq+jevTuZmZlMnTqVF198kfT0dG688Uaio6NLxHr77beTnZ3Niy++yD333GNtL+sxf/PNN2nbti3PPvssL774Ira2ttx+++38+OOPJba1atUqJk2axB133MGbb75p/SJZnnWsXbuWhx9+mDvvvJNp06bx559/MnjwYN555x3eeust7rvvPh599FE2bNjA3XffXWL7lzo2t9xyCyNGjADg9ddft54fRZfJvfDCC4wdO5aGDRsyc+ZMHnroIVauXEn37t1L1ESdOnWKAQMG0KZNG9544w169uxZYn8qy8SJE9m2bRtTp07l3//+Nz/88AP3339/mZZ96aWX+Pbbb3nkkUd48skn2bhxI6NGjSrW57333uP++++nbt26vPLKK3Tr1o1hw4Zx5MiRMm2jLJ9BRQ4cOMBtt91Gnz59+M9//oOXlxfjxo0rkRRczMiRI/nhhx84c+YMYEncFi5ceMEv5nPmzCEqKgobGxtmzJjBPffcw6JFi+jatav17xwVFWVNNP/uq6++om/fvnh5eV0wpor4rCkyd+5cBg0ahKurKy+//DJPP/00u3fvpmvXriV+QCgoKKBfv374+Pjw2muv0aNHD/7zn//w4YcfWvusWLGCESNG4OXlxcsvv8xLL71EZGRkiR9gKkJISAidO3fm888/t7YtXbqUjIyMUs8HkauWISI1xvLlyw0bGxvDxsbG6Ny5s/HYY48ZP//8s5Gbm1usX2xsrAEY//znP4u1P/LIIwZgrFq1ytp25513Gi4uLsX6bdq0yQCM2bNnl4ihtP7BwcEGYPz+++/Wtp9//tkADCcnJyM+Pt7a/sEHHxiAsXr16mLrBIyJEyda2woLC41BgwYZ9vb2xokTJwzDMIzVq1eXWNYwDOPw4cMl4p0wYYJR2kfY2rVrDcCYP39+sfZly5aV2v53U6dONYCLPgYNGmTt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4csvvzTatm1rODg4GN7e3saoUaOMI0eOlLqOjz76yAAMNze3YlOYF/n7dORFyvJZUzS1fWmPXr16WfutXr3a6Nevn+Hh4WE4OjoaDRo0MMaNG2fExMQUi6O0z/S/v9++/vpro2/fvoafn59hb29v1KtXz7j33nuNpKSkCx/Iv62rtMdfp9S/0Ln6d5qOXK4VJsOo4EpREZG/GTduHF9//XWpl1ddSyZNmsTHH39McnIyzs7OxV779ddf6dmzJwsXLqySmaaul2MuFauwsBBfX19uueUWPvroo+oOR0SkRlGNk4hIBcjJyWHevHnceuutJZImkZooJyenRJ3XZ599RmpqKpGRkdUTlIhIDaYaJxGRK3D8+HF++eUXvv76a06dOsWDDz5Y3SGJlMnGjRuZNGkSt99+Oz4+PmzZsoWPP/6YFi1acPvtt1d3eCIiNY4SJxGRK7B7925GjRqFn58fb7311gXvLyRS04SEhBAUFMRbb71Famoq3t7ejB07lpdeeqnabvorIlKTqcZJRERERETkElTjJCIiIiIicglKnERERERERC7huqtxKiws5NixY7i5uV3yBn8iIiIiInLtMgyD06dPU6dOHczmi48pXXeJ07FjxwgKCqruMEREREREpIZITEykbt26F+1z3SVObm5ugOXguLu7V3M0kJeXx/Lly+nbty92dnbVHY5c43S+SVXTOSdVSeebVDWdc1e/zMxMgoKCrDnCxVx3iVPR5Xnu7u41JnFydnbG3d1dbzipdDrfpKrpnJOqpPNNqprOuWtHWUp4NDmEiIiIiIjIJShxEhERERERuQQlTiIiIiIiIpdw3dU4iYiIiIhUN8MwyM/Pp6CgoLpDuebZ2dlhY2NzxetR4iQiIiIiUoVyc3NJSkoiOzu7ukO5LphMJurWrYurq+sVrUeJk4iIiIhIFSksLOTw4cPY2NhQp04d7O3tyzSjm1wewzA4ceIER44coWHDhlc08qTESURERESkiuTm5lJYWEhQUBDOzs7VHc51wdfXl7i4OPLy8q4ocdLkECIiIiIiVcxs1tfwqlJRI3r6i4mIiIiIiFyCEicREREREZFLUOIkIiIiInIVMZlMfPfdd+Vebtq0abRp06Zcy4SEhPDGG2+Ue1uVbc6cOdjZ2dGrVy8yMjKqZJtKnEREREREaogTJ07w73//m3r16uHg4EBA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fTgcDgB8v9HUa2howPPPP4+HH34Y//N//k9UVlbiBz/4Ae655x7lmK9+9avw+/34h3/4BwwMDOCyyy7DK6+8wrmfdF527NiB06dP47777hv1GH/HLRyCJElSti+CiIiIiIhoNuMcJyIiIiIionEwOBEREREREY2DwYmIiIiIiGgcDE5ERERERETjYHAiIiIiIiIaB4MTERERERHROBiciIiIiIiIxsHgRERERERENA4GJyIioin2mc98Brfeemu2L4OIiKYQgxMREZ2Xz3zmMxAEAZ///OdHPfbAAw9AEAR85jOfmdZr2LZtG/Ly8pSfH3nkEaxevXpaXzNdW1sbBEHAvn37VPt/+MMfYtu2bTN2HURENP0YnIiI6LyVlZXhmWeeQTAYVPaFQiE8/fTTKC8vz+KVXZhIJHJB5+fm5qoCHRERzX0MTkREdN7Wrl2LsrIyPPfcc8q+5557DuXl5VizZo3q2FdeeQWXXXYZ8vLyYLfb8dGPfhTHjx9XHv/Vr34Fq9WKlpYWZd8//uM/YtmyZQgEAuNey7Zt2/Ctb30L+/fvhyAIEARBGfUZGBjA/fffD4fDAZvNhmuuuQb79+9Xzk2NVP3sZz9DZWUljEbjhK65srISALBmzRoIgoCrrroKwOhSvXA4jC9+8YsoKiqC0WjEZZddhsbGRuXxnTt3QhAEvP7661i/fj3MZjMuueQSHD16VDlm//79uPrqq5GTkwObzYZ169ahqalp3P8uREQ0NRiciIjogtx333146qmnlJ9/8Ytf4LOf/eyo4/x+Px588EE0NTXh9ddfhyiKuO2225BIJAAA9957L2688Ubcc889iMViePHFF/Gzn/0Mv/nNb2A2m8e9jk984hP413/9V9TV1aGzsxOdnZ34xCc+AQC488474fF48PLLL2PPnj1Yu3Ytrr32WvT19Snnt7a24o9//COee+45pfRuvGvevXs3AGDHjh3o7OxUBch0X/3qV/HHP/4Rv/zlL7F3714sWbIEmzdvVr0+APy3//bf8G//9m9oamqCVqvFfffdpzx2zz33oLS0FI2NjdizZw8eeugh6HS6cf+7EBHRFJGIiIjOw9atW6VbbrlF8ng8ksFgkNra2qS2tjbJaDRK3d3d0i233CJt3bp1zPO7u7slANKBAweUfX19fVJpaan0hS98QXI6ndL//t//+5zX8NRTT0m5ubnKz9/85jelVatWqY55++23JZvNJoVCIdX+6upq6cknn1TO0+l0ksfjOefrjbzmkydPSgCkDz74QHVc6r+NJEnS0NCQpNPppN/85jfK45FIRCopKZEef/xxSZIk6f/9v/8nAZB27NihHPPiiy9KAKRgMChJkiTl5ORI27ZtO+f1ERHR9OGIExERXRCHw4GbbroJ27Ztw1NPPYWbbroJhYWFo45raWnBpz71KVRVVcFms2Hx4sUAgNOnTyvH5Ofn4+c//zmeeOIJVFdX46GHHrrg69u/fz+GhoZgt9thtVqV7eTJk6qyu4qKCjgcjklf83iOHz+OaDSKSy+9VNmn0+mwYcMGHD58WHXsypUrle+Li4sBAB6PBwDw4IMP4v7778emTZvw2GOPqa6diIimnzbbF0BERHPffffdh3/6p38CAPz7v/97xmNuvvlmVFRU4Kc//SlKSkqQSCRQX18/qhHDW2+9BY1Gg87OTvj9fuTk5FzQtQ0NDaG4uBg7d+4c9Vh6AweLxXLe1zxV0kvvBEEAAKUs8JFHHsHdd9+NF198ES+//DK++c1v4plnnsFtt902LddCRERqHHEiIqILdsMNNyASiSAajWLz5s2jHu/t7cXRo0fxjW98A9deey2WL1+O/v7+Uce9++67+O53v4u//OUvsFqtShibKL1ej3g8rtq3du1auN1uaLVaLFmyRLVlGhmbzDXr9XoAGPWa6aqrq6HX6/HOO+8o+6LRKBobG7FixYpJ3V9tbS2+/OUv47XXXsPtt9+umltGRETTiyNORER0wTQajVJ2ptFoRj2en58Pu92On/zkJyguLsbp06dHleH5fD58+tOfxhe/+EVs2bIFpaWlaGhowM0334yPf/zjE7qOxYsX4+TJk9i3bx9KS0uRk5ODTZs24eKLL8att96Kxx9/HLW1tejo6MCLL76I2267DevXr8/4XBO55qKiIphMJrzyyisoLS2F0WhEbm6u6hiLxYIvfOEL+MpXvoKCggKUl5fj8ccfRyAQwN/93d9N6L6CwSC+8pWv4OMf/zgqKytx9uxZNDY24o477pjQ+UREdOE44kRERFPCZrPBZrNlfEwURTzzzDPYs2cP6uvr8eUvfxnf+973VMd86UtfgsViwaOPPgoAuOiii/Doo4/ic5/7HNrb2yd0DXfccQduuOEGXH311XA4HPjtb38LQRDw0ksv4YorrsBnP/tZ1NbW4pOf/CROnToFp9M55nNN5Jq1Wi1+9KMf4cknn0RJSQluueWWjM/12GOP4Y477sCnP/1prF27Fq2trXj11VeRn58/ofvSaDTo7e3Fvffei9raWtx1113YsmULvvWtb03ofCIiunCCJElSti+CiIiIiIhoNuOIExERERER0TgYnIiIiIiIiMbB4ERERERERDQOBiciIiIiIqJxMDgRERERERGNg8GJiIiIiIhoHAxORERERERE42BwIiIiIiIiGgeDExERERER0TgYnIiIiIiIiMbB4ERERERERDSO/x+3uNUA+N0FigAAAABJRU5ErkJggg==\n"},"metadata":{}}]},{"cell_type":"markdown","source":["![image.png](data:image/png;base64,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)"],"metadata":{"id":"T1O1faHLKMeB"}},{"cell_type":"code","source":["!pip install mpi4py\n","!pip install POT\n","!nvidia-smi\n","!pip install -q --upgrade cupy-cuda12x\n","!pip install softimpute         # notice: no underscore\n","# ============================================================================ #\n","# CELL 1: Project Setup, Imports, Logging, Config\n","# ============================================================================ #\n","import os\n","import sys\n","import time\n","import math\n","import re\n","import gc\n","import logging\n","from pathlib import Path\n","from typing import Tuple, List, Dict, Optional, Union, Callable, Any\n","import numpy as np\n","import pandas as pd\n","import matplotlib.pyplot as plt\n","from scipy import sparse\n","from scipy.sparse.linalg import svds, LinearOperator # Import LinearOperator\n","from scipy.optimize import OptimizeResult # For line search return consistency\n","from numpy.random import default_rng, Generator\n","from sklearn.model_selection import train_test_split # For train/validation split\n","# --- Mount Google Drive ---\n","from google.colab import drive # Uncomment if using Colab\n","drive.mount(\"/content/drive\", force_remount=True)\n","DRIVE_MOUNTED = True\n","# right after the imports\n","import logging\n","logging.disable(logging.WARNING)   # hides all warnings emitted via logging\n","\n","# === ADDED Block 5 (MPI) ===\n","try:\n","    from mpi4py import MPI\n","    COMM = MPI.COMM_WORLD\n","    RANK_MPI = COMM.Get_rank()\n","    SIZE_MPI = COMM.Get_size()\n","    if RANK_MPI == 0: print(f\"+++ MPI Detected: Running with {SIZE_MPI} processes. +++\")\n","except ImportError:\n","    COMM = None\n","    RANK_MPI = 0\n","    SIZE_MPI = 1\n","    # print(\"+++ MPI Not Found: Running in serial mode. +++\") # Less verbose\n","\n","# === ADDED Block 6 === (Import for OT demo)\n","try:\n","    import ot\n","    OT_AVAILABLE = True\n","except ImportError:\n","    OT_AVAILABLE = False\n","    if RANK_MPI == 0: print(\"Warning: POT library not found. Skipping Barycentre demo.\")\n","\n","# === ADDED Block 6 (PCA) ===\n","try:\n","    from sklearn.decomposition import PCA\n","    PCA_AVAILABLE = True\n","except ImportError:\n","    PCA_AVAILABLE = False\n","    if RANK_MPI == 0: print(\"Warning: sklearn not found. Skipping PCA trajectory plot.\")\n","\n","\n","# --- Logging Setup (Initialize Logger FIRST) ---\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format=\"%(asctime)s [%(levelname)s] %(message)s\",\n","    handlers=[logging.StreamHandler(sys.stdout)],\n","    force=True, # Overwrite any existing config\n",")\n","logger = logging.getLogger(__name__)\n","\n","# --- Mount Drive ---\n","if RANK_MPI == 0: print(\"+++ Mounting Google Drive +++\")\n","try:\n","    # Only rank 0 should try to force remount if needed\n","    drive.mount('/content/drive', force_remount=(RANK_MPI == 0))\n","    if RANK_MPI == 0: print(\"Drive mounted.\")\n","    if COMM and SIZE_MPI > 1: COMM.Barrier() # Ensure drive is mounted\n","except Exception as e:\n","    if RANK_MPI == 0: print(f\"Error mounting drive: {e}\")\n","    if COMM and SIZE_MPI > 1: COMM.Abort()\n","    raise\n","\n","# --- Optional: Try importing CuPy for GPU acceleration ---\n","# NOTE: Efficient SoftImpute implementation below uses SciPy sparse ops,\n","# GPU acceleration would require re-implementing the LinearOperator with CuPy sparse.\n","try:\n","    import cupy as cp\n","    import cupyx.scipy.sparse as cpx\n","    CUPY_AVAILABLE = False # Disable GPU for SoftImpute for now due to LinearOperator complexity\n","    logger.warning(\"CuPy found, but GPU acceleration for efficient SoftImpute is NOT enabled in this version.\")\n","    if 'cp' not in locals(): cp = np\n","    if 'cpx' not in locals(): cpx = sparse\n","except ImportError:\n","    CUPY_AVAILABLE = False\n","    cp = np ; cpx = sparse\n","    logger.warning(\"CuPy not found, will run on CPU using NumPy/SciPy.\")\n","\n","logger.info(\"+++ Cell 1: Setup, Imports, Logging, Config +++\")\n","\n","# --- Global Config ---\n","# --- MOVIELENS 1M Configuration ---\n","DATA_DIR_STR = \"/content/drive/MyDrive/ml-1m\" # ADJUST PATH AS NEEDED\n","RATINGS_FILENAME = \"ratings.dat\"\n","VALIDATION_FRACTION = 0.2 # Hold out 20% for validation\n","# --- USE COMPLETE DATASET (FIX 1) ---\n","RATING_LIMIT = None # Load all ratings from ml-1m\n","RANK = 10 # Factorization rank (r in paper) for non-convex\n","LAM = 1e-2 # Regularization parameter λ\n","LAM_SQ = LAM ** 2 # λ^2 for non-convex model factor regularization\n","LAM_BIAS = 1e-4 # Regularization for bias terms\n","SEED = 0 # Use consistent seed from long.txt\n","# --- INCREASED ITERATIONS ---\n","N_ITERS_ALL = 20 # Iterations/epochs for ALL solvers\n","CONVEX_RANK_K = 50 # Max rank for Soft-Impute intermediate SVDs\n","SOFT_IMPUTE_TOL = 1e-4 # Convergence tolerance for Soft-Impute\n","N_ITERS_CONVEX = N_ITERS_ALL # Use same number of iterations for SoftImpute\n","# --- SVRG Params ---\n","INIT_LR_SVRG = 1e-3 # Base Learning rate for SVRG inner solver\n","SVRG_INNER_STEPS_DIVISOR = 1 # Use full inner pass\n","GRAD_CLIP_THRESHOLD = 10.0 # Max norm for SVRG gradients before update\n","RSVRG_BATCH_SIZE = 100 # Batch size for non-convex SVRG refresh step\n","# --- ALS Params ---\n","ALS_TOL = 1e-4 # Convergence tolerance for ALS based on RMSE change\n","ALS_MAX_ITER = N_ITERS_ALL # Use same iter count as others for comparison\n","# --- RGD/Accelerated Params ---\n","INIT_LR_RIEMANN = 0.5 # Initial LR for RGD/RAGD/Catalyst/DANE line search\n","LS_BETA = 0.5         # Line search reduction factor\n","LS_SIGMA = 1e-4       # Sufficient decrease parameter\n","RAGD_GAMMA = 1.0; RAGD_MU = 5.0; RAGD_BETA = 5.0\n","DANE_KAPPA = 1.0\n","KAPPA_0 = 1e-1; KAPPA_CVX = 1e-1; INNER_T = 5; INNER_S_BASE = 10; MAX_KAPPA_DOUBLINGS = 10\n","# --- Smaller Initialization Scale ---\n","INIT_SCALE_NON_CONVEX = 0.01 # Smaller scale for initial U, W\n","# --- Configuration from Proposal/long.txt ---\n","RETRACTION_NAME = \"orthonormal\"  # Options: \"orthonormal\", \"cayley\", \"projection\"\n","REG_DISTANCE = \"euclid\"      # Options: \"euclid\", \"retraction\"\n","INNER_SOLVER = \"svrg\"        # Options: \"svrg\", \"sarah\", \"spider\" (for Catalyst)\n","ETA_GRAD = 1e-3              # Adaptive stopping tolerance for inner grad norm\n","ETA_DIST = 1e-4              # Adaptive stopping tolerance for inner step size\n","CATALYST_INNER_T_EPOCHS = 1 # Epochs for Alg phi_1 check budget\n","CATALYST_INNER_S_EPOCHS_BASE = 2 # Base epochs for S_k schedule\n","RSVRG_LR = 1e-3              # Step size for RSVRG/SARAH/SPIDER inner loops\n","\n","# --- Derived Globals ---\n","GLOBAL_RNG = default_rng(SEED)\n","DATA_DIR = Path(DATA_DIR_STR)\n","I_r = np.eye(RANK, dtype=np.float64) # Identity matrix of size RANK\n","\n","# Check Data Directory\n","if DRIVE_MOUNTED and not DATA_DIR.is_dir():\n","    if RANK_MPI == 0: logger.warning(f\"DATA_DIR '{DATA_DIR}' not found. Please check the path.\")\n","elif not DRIVE_MOUNTED:\n","     if RANK_MPI == 0: logger.warning(f\"Google Drive not mounted.\")\n","\n","logger.info(\"Cell 1 initialisation complete.\")"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"j7kCzvnkAqyu","executionInfo":{"status":"ok","timestamp":1746544804485,"user_tz":240,"elapsed":184907,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}},"outputId":"c8766363-e883-49af-d922-886c79301b05"},"execution_count":5,"outputs":[{"output_type":"stream","name":"stdout","text":["Collecting mpi4py\n","  Downloading mpi4py-4.0.3.tar.gz (466 kB)\n","\u001b[?25l     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m0.0/466.3 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K     \u001b[91m━━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[90m╺\u001b[0m\u001b[90m━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m256.0/466.3 kB\u001b[0m \u001b[31m7.4 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\r\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m466.3/466.3 kB\u001b[0m \u001b[31m7.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25h  Installing build dependencies ... \u001b[?25l\u001b[?25hdone\n","  Getting requirements to build wheel ... \u001b[?25l\u001b[?25hdone\n","  Installing backend dependencies ... \u001b[?25l\u001b[?25hdone\n","  Preparing metadata (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","Building wheels for collected packages: mpi4py\n","  Building wheel for mpi4py (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","  Created wheel for mpi4py: filename=mpi4py-4.0.3-cp311-cp311-linux_x86_64.whl size=4458269 sha256=9c333f409cb08f05f3622d5f625eb4063c05337b64cf0a82365ef9c2d9a62627\n","  Stored in directory: /root/.cache/pip/wheels/5c/56/17/bf6ba37aa971a191a8b9eaa188bf5ec855b8911c1c56fb1f84\n","Successfully built mpi4py\n","Installing collected packages: mpi4py\n","Successfully installed mpi4py-4.0.3\n","Collecting POT\n","  Downloading POT-0.9.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (34 kB)\n","Requirement already satisfied: numpy>=1.16 in /usr/local/lib/python3.11/dist-packages (from POT) (2.0.2)\n","Requirement already satisfied: scipy>=1.6 in /usr/local/lib/python3.11/dist-packages (from POT) (1.15.2)\n","Downloading POT-0.9.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (897 kB)\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m897.5/897.5 kB\u001b[0m \u001b[31m15.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hInstalling collected packages: POT\n","Successfully installed POT-0.9.5\n","/bin/bash: line 1: nvidia-smi: command not found\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m105.4/105.4 MB\u001b[0m \u001b[31m11.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m54.6/54.6 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25h\u001b[31mERROR: Could not find a version that satisfies the requirement softimpute (from versions: none)\u001b[0m\u001b[31m\n","\u001b[0m\u001b[31mERROR: No matching distribution found for softimpute\u001b[0m\u001b[31m\n","\u001b[0mMounted at /content/drive\n","+++ MPI Detected: Running with 1 processes. +++\n","+++ Mounting Google Drive +++\n","Mounted at /content/drive\n","Drive mounted.\n"]}]},{"cell_type":"code","source":["# ============================================================================ #\n","# CELL 2: Data Loading and Preprocessing (MovieLens 1M)\n","# ============================================================================ #\n","logger.info(\"+++ Cell 2: Loading and Processing Data (MovieLens 1M) +++\")\n","# --- Manifold Operations ---\n","# --- universal 2-tuple helper for loss/grad (used by Catalyst) ---\n","def stochastic_gradient_batch(U, user_ids, N_users, N_movies, loss_args):\n","    \"\"\"\n","    Vectorised version of `stochastic_gradient_single_user`.\n","    Accumulates the (un-scaled) gradient over the provided user_ids.\n","    \"\"\"\n","    G = np.zeros_like(U, dtype=np.float32)\n","    for uid in user_ids:\n","        G += stochastic_gradient_single_user(U, int(uid), N_users, N_movies, loss_args)\n","    return G / max(1, len(user_ids))          # average over the batch\n","\n","def loss_and_grad_corrected(U, W, bu, bi, *rest):\n","    \"\"\"\n","    Wrapper for loss_and_grad_serial_with_biases that returns:\n","        • the scalar objective value (`loss`)\n","        • the Euclidean gradient w.r.t. U only (`gU`)\n","    \"\"\"\n","    loss, gU, *_ = loss_and_grad_serial_with_biases(U, W, bu, bi, *rest)\n","    return loss, gU\n","# ----------------------------------------------------------------------------\n","# 1) CombinedGradient class\n","# ----------------------------------------------------------------------------\n","class CombinedGradient:\n","    \"\"\"\n","    A container for (grad_U, grad_W). Enables addition, subtraction,\n","    scalar multiplication, and copying.\n","    \"\"\"\n","    def __init__(self, grad_U: np.ndarray, grad_W: np.ndarray):\n","        self.grad_U = grad_U\n","        self.grad_W = grad_W\n","\n","    def __add__(self, other: \"CombinedGradient\") -> \"CombinedGradient\":\n","        return CombinedGradient(self.grad_U + other.grad_U,\n","                                self.grad_W + other.grad_W)\n","\n","    def __sub__(self, other: \"CombinedGradient\") -> \"CombinedGradient\":\n","        return CombinedGradient(self.grad_U - other.grad_U,\n","                                self.grad_W - other.grad_W)\n","\n","    def __mul__(self, scalar: float) -> \"CombinedGradient\":\n","        return CombinedGradient(self.grad_U * scalar,\n","                                self.grad_W * scalar)\n","\n","    def __rmul__(self, scalar: float) -> \"CombinedGradient\":\n","        return self.__mul__(scalar)\n","\n","    def __neg__(self) -> \"CombinedGradient\":\n","        return CombinedGradient(-self.grad_U, -self.grad_W)\n","\n","    def copy(self) -> \"CombinedGradient\":\n","        return CombinedGradient(self.grad_U.copy(), self.grad_W.copy())\n","\n","    def astype(self, dtype) -> \"CombinedGradient\":\n","        return CombinedGradient(self.grad_U.astype(dtype),\n","                                self.grad_W.astype(dtype))\n","\n","\n","def OrthRetraction(U: np.ndarray, V: np.ndarray) -> np.ndarray:\n","    \"\"\"\n","    QR-based retraction to the Stiefel / Grassmann manifold.\n","    Uses *reduced* QR so it works on NumPy ≥1.26 and CuPy.\n","    \"\"\"\n","    # Handle potential zero V vector to avoid QR issues\n","    if np.linalg.norm(V) < 1e-12:\n","        return U.astype(np.float32)\n","\n","    # --- FIX: Check for non-finite input ---\n","    UV = U + V\n","    if not np.isfinite(UV).all():\n","        logger.warning(\"OrthRetraction: Input U+V contains non-finite values. Returning original U.\")\n","        return U.astype(np.float32)\n","    # --------------------------------------\n","\n","    try:\n","        # --- FIX: Use mode='reduced' ---\n","        Q, R_qr = np.linalg.qr(UV, mode='reduced')\n","        # ------------------------------\n","\n","        # Ensure Q has the same shape as U\n","        if Q.shape[1] < U.shape[1]:\n","             pad_width = U.shape[1] - Q.shape[1]\n","             Q = np.pad(Q, ((0, 0), (0, pad_width)), mode='constant')\n","             logger.warning(f\"OrthRetraction: Padded Q due to rank collapse (V norm: {np.linalg.norm(V):.2e})\")\n","        # Optional: Fix sign ambiguity by matching diagonal of R_qr to be positive\n","        # sign_diag = np.sign(np.diag(R_qr))\n","        # sign_diag[sign_diag == 0] = 1 # Avoid multiplying by zero\n","        # Q = Q @ np.diag(sign_diag)\n","        return Q.astype(np.float32)\n","    except np.linalg.LinAlgError:\n","        logger.warning(f\"OrthRetraction: QR decomposition failed (V norm: {np.linalg.norm(V):.2e}). Returning original U.\")\n","        return U.astype(np.float32)\n","    except ValueError as e: # Catch potential value errors from qr\n","        logger.error(f\"OrthRetraction: ValueError during QR: {e}. Returning original U.\")\n","        return U.astype(np.float32)\n","    except Exception as e: # Catch any other unexpected errors\n","        logger.error(f\"OrthRetraction failed with unexpected error: {e}\")\n","        return U.astype(np.float32)\n","# Initialize default values\n","N_users_active, M_movies_active = 0, 0\n","R_train_coo = sparse.coo_matrix((0, 0), dtype=np.float64)\n","R_train_coo_orig = sparse.coo_matrix((0, 0), dtype=np.float64) # For original ratings\n","R_train_csr_orig = sparse.csr_matrix((0,0), dtype=np.float64) # For SoftImpute _matvec\n","R_train_csc_orig = sparse.csc_matrix((0,0), dtype=np.float64) # For SoftImpute _rmatvec\n","ratings_train_orig = np.array([], dtype=np.float64) # Keep original ratings for viz\n","ratings_train_centered = np.array([], dtype=np.float64)\n","mapped_user_ids_train, mapped_movie_ids_train = np.array([], dtype=np.int32), np.array([], dtype=np.int32)\n","user_ids_val_final, movie_ids_val_final, ratings_val_true = (np.array([], dtype=np.int32), np.array([], dtype=np.int32), np.array([], dtype=np.float64))\n","global_mean_rating = 0.0\n","user_map_global_to_local = {}\n","movie_map_global_to_local = {}\n","unique_users_train = np.array([], dtype=np.int32)\n","unique_movies_train = np.array([], dtype=np.int32)\n","DATA_AVAILABLE = False\n","user_data_arrays = {} # Precompute user data for ALS/SVRG\n","sampling_prob = None # Initialize sampling probability\n","RSVRG_EPOCH_LEN = 1 # Default epoch length\n","\n","ratings_file_path = DATA_DIR / RATINGS_FILENAME\n","\n","if DRIVE_MOUNTED and ratings_file_path.is_file():\n","    logger.info(f\"Loading MovieLens 1M data from: {ratings_file_path}\")\n","    try:\n","        ratings_df = pd.read_csv(\n","            ratings_file_path, sep='::', header=None,\n","            names=['user_id', 'movie_id', 'rating', 'timestamp'],\n","            engine='python', encoding='latin-1'\n","        )\n","        logger.info(f\"Loaded {len(ratings_df)} ratings.\")\n","        DATA_AVAILABLE = True\n","\n","        if RATING_LIMIT is not None and RATING_LIMIT > 0 and len(ratings_df) > RATING_LIMIT:\n","             logger.info(f\"Subsampling ratings from {len(ratings_df)} to {RATING_LIMIT}\")\n","             ratings_df = ratings_df.sample(n=RATING_LIMIT, random_state=SEED)\n","\n","        stratify_arg = ratings_df['user_id'] if RATING_LIMIT is None else None\n","        if stratify_arg is None and RATING_LIMIT is not None:\n","            logger.warning(\"Stratify is disabled due to RATING_LIMIT being set.\")\n","        train_df, val_df = train_test_split(\n","            ratings_df, test_size=VALIDATION_FRACTION, random_state=SEED, stratify=stratify_arg)\n","        logger.info(f\"Train size: {len(train_df)}, Validation size: {len(val_df)}\")\n","\n","        user_ids_train_orig = train_df['user_id'].values; movie_ids_train_orig = train_df['movie_id'].values\n","        ratings_train_orig = train_df['rating'].values.astype(np.float64)\n","        user_ids_val_orig = val_df['user_id'].values; movie_ids_val_orig = val_df['movie_id'].values\n","        ratings_val_true = val_df['rating'].values.astype(np.float64) # Keep original for validation\n","\n","        global_mean_rating = ratings_train_orig.mean()\n","        logger.info(f\"Global mean rating (training): {global_mean_rating:.4f}\")\n","\n","        unique_users_train, mapped_user_ids_train = np.unique(user_ids_train_orig, return_inverse=True)\n","        unique_movies_train, mapped_movie_ids_train = np.unique(movie_ids_train_orig, return_inverse=True)\n","        N_users_active = len(unique_users_train); M_movies_active = len(unique_movies_train)\n","        user_map_global_to_local = {orig_id: local_id for local_id, orig_id in enumerate(unique_users_train)}\n","        movie_map_global_to_local = {orig_id: local_id for local_id, orig_id in enumerate(unique_movies_train)}\n","        logger.info(f\"Active users in training: {N_users_active}, Active movies in training: {M_movies_active}\")\n","\n","        ratings_train_centered = ratings_train_orig - global_mean_rating\n","\n","        val_user_mask = np.isin(user_ids_val_orig, unique_users_train)\n","        val_movie_mask = np.isin(movie_ids_val_orig, unique_movies_train)\n","        val_valid_mask = val_user_mask & val_movie_mask\n","        user_ids_val_filt = user_ids_val_orig[val_valid_mask]; movie_ids_val_filt = movie_ids_val_orig[val_valid_mask]\n","        ratings_val_true = ratings_val_true[val_valid_mask] # Filter true ratings accordingly\n","        user_ids_val_final = np.array([user_map_global_to_local.get(uid, -1) for uid in user_ids_val_filt], dtype=np.int32)\n","        movie_ids_val_final = np.array([movie_map_global_to_local.get(mid, -1) for mid in movie_ids_val_filt], dtype=np.int32)\n","        valid_map_mask = (user_ids_val_final != -1) & (movie_ids_val_final != -1) # Filter out any potential misses\n","        user_ids_val_final = user_ids_val_final[valid_map_mask]; movie_ids_val_final = movie_ids_val_final[valid_map_mask]\n","        ratings_val_true = ratings_val_true[valid_map_mask] # Filter again after mapping\n","        logger.info(f\"Validation pairs mapped to training users/movies: {len(user_ids_val_final)}\")\n","\n","        if ratings_train_centered.size > 0:\n","            R_train_coo = sparse.coo_matrix((ratings_train_centered, (mapped_movie_ids_train, mapped_user_ids_train)), shape=(M_movies_active, N_users_active), dtype=np.float64)\n","            R_train_coo.eliminate_zeros()\n","            logger.info(f\"Built sparse training matrix (Centered) R_train_coo: shape={R_train_coo.shape}, nnz={R_train_coo.nnz}\")\n","            R_train_coo_orig = sparse.coo_matrix((ratings_train_orig, (mapped_movie_ids_train, mapped_user_ids_train)), shape=(M_movies_active, N_users_active), dtype=np.float64)\n","            R_train_coo_orig.eliminate_zeros()\n","            R_train_csr_orig = R_train_coo_orig.tocsr(); R_train_csc_orig = R_train_coo_orig.tocsc()\n","            logger.info(f\"Built sparse training matrix (Original) R_train_coo_orig: shape={R_train_coo_orig.shape}, nnz={R_train_coo_orig.nnz}\")\n","\n","            # Precompute user data structures for ALS/SVRG\n","            logger.info(\"Precomputing user data structures...\")\n","            t_precomp_start = time.time()\n","            user_data_arrays = {}\n","            for r, c, v in zip(R_train_coo_orig.row, R_train_coo_orig.col, R_train_coo_orig.data):\n","                user_data_arrays.setdefault(c, []).append((r, v))\n","            for u, rating_list in user_data_arrays.items():\n","                if rating_list:\n","                    movie_indices_list, rs_list = zip(*rating_list)\n","                    user_data_arrays[u] = {'movies': np.array(list(movie_indices_list),dtype=np.int32),\n","                                           'rs': np.array(list(rs_list),dtype=np.float64)} # Store original ratings\n","            logger.info(f\"User data precomputation done in {time.time() - t_precomp_start:.2f}s\")\n","            # Calculate importance sampling weights (consistent across ranks)\n","            all_user_indices_global = np.array(list(user_data_arrays.keys()), dtype=np.int32)\n","            num_active_users_global = len(all_user_indices_global)\n","            user_weights = None; use_importance_sampling = False\n","            if num_active_users_global > 0:\n","                if RANK_MPI == 0: print(\"Calculating importance sampling weights...\")\n","                user_ratings_count = [len(user_data_arrays[u_idx]['movies']) if u_idx in user_data_arrays and 'movies' in user_data_arrays[u_idx] else 0 for u_idx in all_user_indices_global]\n","                user_weights_np = np.array(user_ratings_count, dtype=np.float64)\n","                sum_weights = user_weights_np.sum()\n","                if sum_weights > 1e-9:\n","                    user_weights_np /= sum_weights\n","                    user_weights = user_weights_np # Probabilities aligned with all_user_indices_global\n","                    use_importance_sampling = True\n","                    if RANK_MPI == 0: print(f\"Importance sampling enabled (weights based on {sum_weights:.0f} ratings).\")\n","                else:\n","                     if RANK_MPI == 0: print(\"Warning: Cannot compute importance sampling weights. Using uniform.\")\n","            else:\n","                 if RANK_MPI == 0: print(\"No active users, cannot use importance sampling.\")\n","            sampling_prob = user_weights if use_importance_sampling else None\n","            RSVRG_EPOCH_LEN = math.ceil(num_active_users_global / RSVRG_BATCH_SIZE) if num_active_users_global > 0 else 1\n","            if RANK_MPI == 0: print(f\"RSVRG Epoch Length set to {RSVRG_EPOCH_LEN} batches.\")\n","\n","        else: logger.error(\"No training ratings available.\")\n","\n","    except FileNotFoundError: logger.error(f\"MovieLens file not found: {ratings_file_path}\"); DATA_AVAILABLE = False\n","    except Exception as e: logger.error(f\"Error processing MovieLens: {e}\", exc_info=True); DATA_AVAILABLE = False\n","elif not DRIVE_MOUNTED: logger.error(\"Google Drive not mounted.\")\n","else: logger.error(f\"Data directory {DATA_DIR} or ratings file {RATINGS_FILENAME} not found.\")\n","\n","gc.collect()\n","logger.info(\"Cell 2: Data Loading and Preprocessing Complete.\")\n","logger.info(f\"Active Dimensions: M_movies={M_movies_active}, N_users={N_users_active}\")\n","logger.info(f\"Training Ratings: {R_train_coo.nnz}\")\n","logger.info(f\"Validation Ratings (for RMSE): {ratings_val_true.size}\")\n","\n","# Add this after Cell 2: Data Loading and Preprocessing (around line 180-200)\n","# Create mask matrices needed for RUNRSVRG and define active_idx\n","# Add this after Cell 2: Data Loading and Preprocessing (around line 180-200)\n","# Create mask matrices needed for RUNRSVRG and define active_idx\n","if DATA_AVAILABLE and R_train_coo.shape[0] > 0 and R_train_coo.shape[1] > 0:\n","    # Create mask from R_train_coo (centered ratings)\n","    R_train_mask_coo = R_train_coo.copy()\n","    if R_train_mask_coo.data is not None:\n","        R_train_mask_coo.data[:] = 1\n","    else:\n","        # Handle case where R_train_coo is empty\n","        R_train_mask_coo = sparse.coo_matrix(R_train_coo.shape, dtype=np.uint8)\n","    R_train_mask_coo.eliminate_zeros()\n","\n","    # Create probe mask from validation indices\n","    if user_ids_val_final.size > 0 and movie_ids_val_final.size > 0:\n","        Probe_mask_coo = sparse.coo_matrix(\n","            (np.ones_like(user_ids_val_final, dtype=np.uint8), (movie_ids_val_final, user_ids_val_final)),\n","            shape=(M_movies_active, N_users_active),\n","            dtype=np.uint8\n","        )\n","        Probe_mask_coo.eliminate_zeros()\n","    else:\n","         Probe_mask_coo = sparse.coo_matrix((M_movies_active, N_users_active), dtype=np.uint8)\n","\n","\n","    # Define active_idx for stochastic solvers (assuming stochasticity over users)\n","    # This should align with how the inner stochastic gradient functions are implemented\n","    # Assuming active_idx refers to indices of users with ratings\n","    active_idx = unique_users_train # Use the mapped indices of active users\n","\n","    # Also define initial biases for the RUNRSVRG call\n","    # These might not be updated within RUNRSVRG's core loop, but needed for RMSE evaluation signature\n","    # Assuming they are initialized globally alongside other solvers\n","    initial_user_bias = np.zeros(N_users_active, dtype=np.float64) # Placeholder, assumes initialization happens elsewhere\n","    initial_movie_bias = np.zeros(M_movies_active, dtype=np.float64) # Placeholder\n","\n","    # global_actual_loaded is not defined, use R_train_coo.nnz for total ratings count if needed\n","    total_ratings_count = R_train_coo.nnz\n","\n","else:\n","    # Handle case where no data is available\n","    R_train_mask_coo = sparse.coo_matrix((0, 0), dtype=np.uint8)\n","    Probe_mask_coo = sparse.coo_matrix((0, 0), dtype=np.uint8)\n","    active_idx = np.array([], dtype=np.int32)\n","    initial_user_bias = np.array([], dtype=np.float64)\n","    initial_movie_bias = np.array([], dtype=np.float64)\n","    total_ratings_count = 0\n","\n","import time\n","import logging\n","from typing import Dict, Optional, Union\n","import numpy as np\n","from numpy.random import Generator, default_rng\n","def INITIALIZEU(M, r, rng):\n","    \"\"\"Random initialization of U.\"\"\"\n","    U = rng.standard_normal((M, r))\n","    Q, _ = np.linalg.qr(U, mode='reduced')\n","    return Q.astype(np.float64)\n","def full_loss_and_grad_unprofiled(U, W, user_data_arrays, lam_sq, N):\n","    \"\"\"Compute full loss and gradient. Placeholder implementation.\"\"\"\n","    loss = np.linalg.norm(U)**2 + np.linalg.norm(W)**2  # simple regularization as placeholder\n","    grad_U = 2 * lam_sq * U\n","    grad_W = 2 * lam_sq * W\n","    from collections import namedtuple\n","    GradStruct = namedtuple('GradStruct', ['grad_U', 'grad_W'])\n","    return loss, GradStruct(grad_U=grad_U, grad_W=grad_W)\n","def grad_single_user_combined(U, W, uid, user_data_arrays, lam_sq, total_ratings):\n","    return full_loss_and_grad_unprofiled(U, W, user_data_arrays, lam_sq, total_ratings)[1]\n","\n","def grad_batch_users_combined(U, W, u_batch, user_data_arrays, lam_sq, total_ratings):\n","    return full_loss_and_grad_unprofiled(U, W, user_data_arrays, lam_sq, total_ratings)[1]\n","\n","def PROJ_TANGENT(U, G):\n","    \"\"\"Projection onto tangent space at U (Grassmann).\"\"\"\n","    return G - U @ (U.T @ G)\n","\n","if RANK_MPI == 0: # Only rank 0 should plot\n","    if DATA_AVAILABLE and ratings_train_orig.size > 0:\n","        plt.style.use('seaborn-v0_8-whitegrid') # Use a nice style\n","\n","        # 1. Rating Distribution\n","        plt.figure(figsize=(10, 4))\n","        counts, bins, patches = plt.hist(ratings_train_orig, bins=[0.5, 1.5, 2.5, 3.5, 4.5, 5.5], rwidth=0.8, align='mid', color='skyblue', edgecolor='black')\n","        bin_centers = 0.5 * (bins[:-1] + bins[1:])\n","        for count, x in zip(counts, bin_centers):\n","            if count > 0: plt.text(x, count, str(int(count)), ha='center', va='bottom')\n","        plt.title('Distribution of Training Ratings (MovieLens 1M Subset)')\n","        plt.xlabel('Rating'); plt.ylabel('Frequency')\n","        plt.xticks([1, 2, 3, 4, 5]); plt.grid(axis='y', alpha=0.75)\n","        plt.tight_layout(); plt.show()\n","\n","        # 2. Ratings per User\n","        user_rating_counts = np.bincount(mapped_user_ids_train)\n","        plt.figure(figsize=(10, 4))\n","        plt.hist(user_rating_counts[user_rating_counts > 0], bins=50, log=True, color='lightcoral', edgecolor='black')\n","        plt.title('Distribution of Ratings per User (Training Set)')\n","        plt.xlabel('Number of Ratings Given'); plt.ylabel('Number of Users (log scale)')\n","        plt.grid(axis='y', alpha=0.75); plt.tight_layout(); plt.show()\n","\n","        # 3. Ratings per Movie\n","        movie_rating_counts = np.bincount(mapped_movie_ids_train)\n","        plt.figure(figsize=(10, 4))\n","        plt.hist(movie_rating_counts[movie_rating_counts > 0], bins=50, log=True, color='lightgreen', edgecolor='black')\n","        plt.title('Distribution of Ratings per Movie (Training Set)')\n","        plt.xlabel('Number of Ratings Received'); plt.ylabel('Number of Movies (log scale)')\n","        plt.grid(axis='y', alpha=0.75); plt.tight_layout(); plt.show()\n","        logger.info(\"Cell 2.5: Data Visualization Complete.\")\n","    else:\n","        logger.warning(\"Skipping data visualization as no data was loaded.\")"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"id":"exgdyGvTLxiG","executionInfo":{"status":"ok","timestamp":1746544837537,"user_tz":240,"elapsed":7431,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}},"outputId":"f659bbf3-dcbf-40ac-97fb-a4cd6b9a5684"},"execution_count":7,"outputs":[{"output_type":"stream","name":"stdout","text":["Calculating importance sampling weights...\n","Importance sampling enabled (weights based on 800167 ratings).\n","RSVRG Epoch Length set to 61 batches.\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 1000x400 with 1 Axes>"],"image/png":"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NHXqVK1cuVIhISFq0KCBunbtqqNHj5rmiYuL0/Dhw/X444+b1jNv3jxlZmbmue06deooMjJS1apVu2OdISEhOnjwoH777Tez6V999ZXKlSsnX1/fO64jNTVV6enpOV5rGxsbLVmyRKNHjzZN8/b21owZM8zmmzdvnry9vXXr1i2z6Vu2bFHbtm3l6+urp556Srt27TK1FaQPXr58WaNGjVKrVq3k5+en9u3bmx14bdWqlb7//nt98cUXZv178ODBOnz4sPbs2XPHfQdw/yJ0A0AhhISE6Lfffstxtli6fWZo8uTJ+s9//qOvvvpKK1askJubm/r27auUlBTNmzdPdevWlb+/v/bt22c2FHrRokUaNmxYvqH1559/1oEDB7Rw4UKtWrVKWVlZGjRokCkg3Im/v79mzpwp6fYX1L9+cfyrCRMm6NNPP1VoaKg2b96siIgIHThwQK+++qrZF+KEhATNnz9fEyZM0Pr16/XII49o4sSJOa7B/qs1a9Zo7NixevLJJ7V+/Xp99NFHSk9PV+/evXXx4kX5+/ubgnHfvn21b98+PfDAAwXav7zs2bNHZcuW1caNG9WkSRMlJSXpP//5j+zt7fX5559r8+bN6tGjhyZNmmTadl7mz58vLy8vRUZG6u2339a3336rd999956WmTx5srZv36433nhDq1evlqenp6ZMmXJP+5yWlqbz58/rwQcfNE0LDw/Xxo0b9fbbb2vHjh2aOXOmDhw4oDfeeEPS7WHSI0eOlCStXr0638sOimKfwsPDdfToUb377rv6+uuv9eabb2rHjh2KiIjIc7vfffedkpOT87w++JlnntHXX3+tpKQk07S9e/fq+vXruQ5NHjhwoHbu3KnJkydry5YtGj16tDZs2KBRo0ZJkjp06KA///wzx5nMzZs3q1atWqpTp06Odf74448aMGCAPD099emnn2r58uVKS0tTz549lZCQkOe+5Wbo0KHatGmThg0bpq+++kqvvvqq5s+frwULFpjNt3fvXh05ckSLFi3Sxx9/rGvXrpn2Qbp98CAhIUFLly7Vtm3bNGLECC1fvlwffPBBntuuVKmSSpcuXaA6AwMDVbFixRwHPL744gu1a9cux3D/3DRv3lxHjx7VK6+8om+//VYpKSkF2nZ+4uLiFBkZqenTp2vt2rXy8vJSaGio6TPqTn0wLS1NL7/8sg4dOqTJkydr48aN6tixo+kzT7r9mebh4aGnn35a+/btk7+/v6Tbn7ceHh7asWPHPe8HgJKLa7oBoBCyA+Dly5fNAo0kHTt2TGXKlNGzzz5rGhI9depUnT59WnZ2dnJ3d5e9vb1KlSqV4zrloKAgPfnkk/luOzk5WdOnT5ejo6Ok2+H4xRdf1HfffafWrVvfsXYHBwe5urpKun29c27D1//8809t2LBBI0aMUKdOnSRJVatW1ZgxYxQaGqpDhw4pICBAknTp0iV98MEHql27tiSpX79+2rVrl44fP55nUF66dKmaN29uNjQ4e/jounXrNHjwYFWoUEHS7Wt0//46FcbNmzc1btw42drePt6ckZGhtWvXqly5cqbrvnv16qVFixZp7969+d7wqWbNmurXr58kqVq1amrYsKEMBkO+289vmZSUFG3btk29evVSx44dJUlhYWE6c+aMzp07V6j9jY+P14wZM5SUlGQ6c5293sGDB6tKlSqSbvflp59+WitXrlRWVpZKly4tZ2dnSbfPGud3yUFR7FNUVJQaN25sCikPPPCAPv74YxmNxjy3+9NPP8nJyUl169bNtb1du3aKiIjQV199peeff17S7eDXrFkz02UI2X755RcdPHhQs2fPNv3tValSRRcvXtS0adN04cIFBQUFqXz58tq6dasaNmwo6fbZ52+//VavvfZarjUsWbJEXl5emj59umnI+cyZM9WyZUt9/vnnGjhwYJ7791dHjhzR/v379dZbb5kO0FWtWlW//vqrPvzwQ/Xv3990CUVSUpLCw8NNv3fs2FHz5s1TUlKSnJ2dFRUVpSFDhpgOEjz44IOqVauWypQpU6Ba7sTW1lbt27fX+vXrNWzYMNna2urUqVOKiorSlClTzM4u52XYsGFKTk7W559/rn379qlUqVLy8/NT8+bN1aVLF1WqVOmu60pISNA777wjT09PSbc/j4ODg7Vt2zb16dPnjn1wx44diomJ0fLly9WkSRNJUv/+/XX48GEtXLhQnTp1koeHh2xtbU2XGWSzsbFRo0aN9OOPP9513QDuH5zpBoBCyMjIkKRcr998/PHHZTQa9fzzz2vVqlU6e/asnJycVL9+/TteX1yQ4Ze+vr6mwC3dHmIpSWfOnLmbXcjXsWPHlJWVZQrW2bK/lB4/ftw0zcnJyRS4JZlC/PXr13Ndd1JSks6dO5dj3RUqVFCVKlXM1l2UfHx8TIFbkuzt7XXx4kWNHj1aLVq0kL+/v/z9/XXlyhUlJibmu6769eub/e7h4aFr164Vepk//vhD6enppiH12Vq0aHGHvbrtypUrpvr9/f1Vv359Pf744zp16pTee+89s23b2tpqxYoVeuqppxQQECB/f3999NFHSk5OVlpaWoG2V5T7FBISos8//1xjx47Vjh07dOPGDVWtWlXVq1fPc7uXLl1ShQoV8jxzWq5cOT3xxBOmM66JiYnauXOnOnTokGPe7IME+fV1e3t7Pf3009q+fbtplMeOHTuUkZGhZ599Ntcajh49qiZNmph9RlSoUEG1atW6qz5+5MgRSVKzZs3Mpjdt2lQ3b940O4BRt25ds8+Y7L/F7PckJCRE8+fPV3h4uPbu3avU1FTVrFlTXl5eBa7nTjp27KiLFy/qu+++k3T7YEeNGjUK9Nkm3T4oOGnSJH377beKiIgwjTKYM2eOWrduXagzxlWqVDEFbkmqXLmy3N3dTZ+Zd+qDR44cUalSpfTYY4+Zrbdp06Y6d+5cnndsz1axYkVdvnz5rusGcP/gTDcAFMJvv/0mGxubHGe5pf9/DeSHH36od999V5MnT1bNmjX1+uuvKyQkJN/1FuRGVdlnqbNl3xG4oMPLCyJ7WO7f68k+A/rXL5l53ZH479dk/n3d2ev6+/rv9AW2sP7+uhkMBvXt21cBAQGKiIhQpUqVZGdnZ7qGOT9/3+eCDJvNb5nskF+2bFmzeQp6Ez13d3dFRkaafj927Jhef/119evXT8HBwabpWVlZ6tevny5cuKAxY8aYDuCsWLHirm+2JhXNPr3++ut65JFHtHbtWg0fPlzS7TvrT5gwIc+zmjdu3Ljj38qzzz6r4cOHKyYmRj/88INKlSqV6+iFgvb1Dh066JNPPtGRI0fUoEEDbdmyRY899pgqV66c6/aTkpK0fv16ffXVV2bTb926dVc398uu76mnnjKbnn0W9vLly6aDXnm9H9l/i9OmTdNnn32mjRs3auXKlXJwcFD79u01duzYIrtJXp06dVSzZk2tW7dOQUFB2rhxo3r06HHX6ylfvry6dOmiLl26SLp92c6oUaM0fvx4tWzZ8q5uWPf3v33p9v0Osj8z79QHk5KSlJ6erkaNGpmtI/vg6+XLl3P0879v/+bNm8rMzLzvbrQHoGAI3QBQCNu2bVPdunXzDEXe3t6aNm2asrKyZDAYtHTpUr322mvavHlzvmfwCuLvoTT7i2P2lz4bG5scgfduA3n2l9QbN26YTc/+PbcvsQWVHWb+er1ttqSkpCI965afr776Sra2tnrvvfdMNRmNxjuesbaE7BD29+tX73TGPZudnZ3Zja6qVaumbdu2aerUqXr88cdNQ8RPnTqlEydO6H//+58pzEi66zPcBVHQfbKxsVGnTp3UqVMn3bx5U3v27NH06dP1+uuva+XKlbmu28XF5Y431mvVqpVcXFy0efNm06UXuQ2j/mtf/2v73/t6gwYNVLVqVW3dulU1atTQd999l+81966urmrWrFmuw8/vJnRnX/qwfPnyXB9/dzeXXpQqVUq9evVSr169lJiYqK+//lrTp09XRkaG3nnnnQKv5046duyo+fPna9euXbp8+XKuIwzycvPmTTk6OuZ4WkHTpk31yiuv6K233tKff/5pOuBZkM+63A7kJScnm31m5tcHXV1dVbp0adP12393p/tNXL9+XWXLliVwA/9iDC8HgLu0YsUKRUVF5XlN5qFDh0xDQm1sbFSvXj2Fh4crMzNTp06dMs2X15ngOzl69KjZXXWz74peq1YtSbcDyfXr101nYaT/P0T17/KqwdfXV7a2tvrpp5/Mph86dEiScgwZvhvOzs6qWbNmjnVfunRJ58+fv6d134309HQ5ODiYnXHfvHmzUlNTC/3eFFbVqlVlY2Njdqdp6fbBncIaN26cUlJSzG5Ilv0YsL8eLEpKStL27dsl5ewP9/I6FGSfUlJS9NVXX5kuRShbtqzatWunl19+WdHR0Xmu29PTU/Hx8fle9+3o6Ki2bdtq8+bNOnz4cJ7BL/v5yQcPHjSbfujQIdna2prdJK19+/basWOHvvnmG9nZ2alNmzZ5br9BgwaKiYlRtWrVzH4yMjLuKihnD+G/dOmS2XpcXV1VpkyZAj37Wrp9sOPLL7803anc3d1d3bp107PPPpvva10YHTp0UFpammbPnm06WFEQx44dU0BAQJ43kvz999/l4OBgui7f1dU1x03pcnuk2G+//aY///zTbD3Xrl1TrVq1CtQHGzRooNTUVKWkpJi9B6VLl5arq6vZQZTc/mYuX75cJPelAFByEboBIA9Go1GXL1/W5cuXTXcunjhxoqZOnaoBAwbkedOyXbt2afDgwdq+fbvi4uJ05swZLVq0SKVLlzYFSldXV507d04GgyHfu3znpnTp0ho/frxOnTqlo0ePaurUqapUqZKCgoIk3Q4R6enpWrRokc6fP68dO3bkuJtw9hmz7777TsePH8/xRbFixYrq3LmzlixZok2bNun8+fP65ptvFBERocDAQFNQKaxXX31Ve/fu1fz583Xu3DkdPnxYw4YNk7u7u5577rl7WndBNWjQQDdv3tRHH32k33//XevWrdPKlSvVoEEDnT59+p4eUXa33Nzc9Pjjj2v16tX6+uuvde7cOb377rv3VEPlypX12muvaf369abrax9++GG5ublp5cqVOnv2rA4fPqxXXnnFdAOxAwcOKCUlxdQ/9uzZo5MnT1psn+zt7fXOO+9o1KhROnr0qC5cuKCff/5ZGzZsyHH97F81btxYycnJpgNOeenYsaPOnDmj8uXLm/4+/q5evXpq0qSJ3n77be3evVvnz5/Xl19+qUWLFqlTp05m1wJ36NBB58+f14oVK/Tkk0/meolEtldeeUUnT57U5MmTdeLECZ07d05LlixRhw4dcjw+KikpyfRZ89efjIwM+fr6qlmzZqY7av/+++/68ccf9corr2jgwIEFPjCSlZWlyZMna8KECTpx4oQuXLig77//Xjt37sz3tb5x44apnvT0dGVkZJh+z+tSkAceeECNGzfWr7/+eldnuX19ffXkk09qypQpmj9/vgwGg/744w8dO3ZMs2bN0ieffKJXXnnFNCKhXr162rlzp3744QedPXtWM2fOzPXO8O7u7ho3bpyioqJ04sQJTZgwQU5OTmrbtm2B+mDLli1Vu3ZtjRw5Ut9//73i4uK0Z88e9ezZUxMnTjRtx9XVVcePH1d0dLTp0XlZWVk6ePBgvq8xgPsfw8sBIA8JCQmmmxfZ2NjIzc1N9evX1/vvv5/jpkZ/NWzYMNnZ2WnatGm6dOmSnJyc5OPjo6VLl5qGIf7nP//RqFGj9OKLL+r111/P9ZFDeWnWrJlq166tV199VVeuXJGPj48WLVpkurlau3btdPjwYX366ad6//335e/vrzfffFPt27c3rcPPz08hISFatmyZ1q5dq7179+bYzuTJk+Xh4aEZM2bo8uXLKleunFq3bq0RI0YUuNa8dOrUSUajUcuWLTMdkHjsscc0derUAl/HfK/at28vg8GgxYsX6913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\n"},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<Figure size 1000x400 with 1 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAAA90AAAGGCAYAAABmGOKbAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAXk1JREFUeJzt3X98zfX///H72dhsttGckDE/YvNjGyu/qRiVpqIVoek9FKkkEZLfP0Ii+ZFfRRFRrKIoDeVHohJGG/KjsTSGYWw22/n+4bPzNfthZztnZ5vb9XLpkj1f5/V8PV7nuRfnfl6v1/NlMJlMJgEAAAAAAKtzsHcBAAAAAACUVIRuAAAAAABshNANAAAAAICNELoBAAAAALARQjcAAAAAADZC6AYAAAAAwEYI3QAAAAAA2AihGwAAAAAAGyF0AwAAAABgI4RuALCD4cOHy9fX1/yfn5+f2rRpo9dff107d+7M8vqgoCANGjTIJnW0atXK5tuRpJ49e6pr16426Tu/li9frpYtW8rf31+nT5/O9jVBQUGZxsrX11f16tVT69atNWzYsBzXs8SpU6fk6+urzz//vMB9FVe+vr567733sl1WVN6fpKQkPfXUUxo3bpxmz56d5ffi1v+CgoIKtL1du3bJ19dXW7dutek6BZGWlqaVK1eqW7duat68uRo0aKBWrVrplVdeUXR0dIH6jo2NVbNmzRQeHm6lagHAPkrZuwAAuFN5enpq7dq1kqSUlBTFxMTo22+/Ve/evfW///1Pw4cPN7929erVKl26dJ77XrNmjb7++mstW7Ys19e9/fbbSk1Nzd8O3Ebbtm01ZcoUNWvWTJI0e/Zsm2ynIKZNm6b7779f48eP1913353j69q1a6dx48aZf05JSVFUVJSmTZumHj16aN26dXJzc8vzdn/99VeNGDFCmzdvliTdc8892r59u9zd3fO/M7C5kSNHymAw6K233lJqaqq6detmXjZ//nx99tln2r59u7nN0dGxQNsLDAzU9u3bVa5cOZuuUxCjR4/W+vXrNXjwYLVq1UqlS5fW0aNH9cEHH6hnz54KDw9XtWrV8tzfrFmz9O+//2rKlCny8vLS1KlTNWDAANWuXVsBAQE23BMAsB1CNwDYiYODQ6ag5+XlpRYtWqhFixYaPHiwateurWeeeUbSjYBuiT///DNPr7NVyIuLi9O///6bqa18+fI22VZ+paSkKCkpSY0aNZKXl1eur3V2ds4Syr28vFShQgV169ZNGzZsUJcuXfK87VvHx9HRMdfQD/v79ddf9e233+qzzz6Tk5OTnJycVLZsWfNyFxcXSbLqODo5OVncX37Wya8rV67oq6++Ut++fRUaGmpur1q1qvz8/NSrVy/t27fPotD9559/qlKlSuaf27Rpo2bNmmnSpElatWqVVesHgMLC5eUAUMQ8/vjjatGihRYuXGhuu/Wy71WrVumJJ55Qo0aN1KRJE/Xu3VsHDx6UdOMy7i+//FK7d++Wr6+vwsPDzZecbtiwQU888YRatGghKevl5RmWL1+utm3bys/PTyEhIdq7d695WXbr3Hz5765du/Tggw9Kkp5//nnzJba3Xl6ekpKi6dOnKygoSH5+fmrZsqWGDx+uc+fOZdpWp06dtGvXLoWEhKhhw4Z6+OGH9dVXX932fQwPD9cTTzwhf39/3X///erTp48OHDgg6cYluP7+/pKkOXPmyNfXV6dOnbptn7eqW7euJOm///4ztx0/flwDBgxQ06ZN5efnp4cffljz5s1Tenq6eZ9mzpyp2NhY+fr6avbs2Vkunw4PD5evr68OHz6sF198UYGBgWrdurXeeecdcz+S9Pfffys0NFQBAQF64IEHtGjRIi1YsEC+vr7m10RHR+vFF19U8+bNFRAQoODg4NteAREUFKRRo0Zp6dKlatOmjfz9/fX0009r//79mV63detWhYaGqmnTprrvvvv04osv6ujRo5nGwNfXVz///LPatWunp59+2uL3OCe5HQOSZDKZ9Mknn6hTp05q1KiRWrZsqdGjR+vSpUvm12T8fn3++edq2rSppk6dmuP25syZoyZNmqhJkyYW1ZnTsSdJn3zyiYKDg+Xn56dmzZqpT58+mS7JvvVS8dmzZ6tx48Y6dOiQevTooUaNGqlNmzaZ/q7IzzqS9McffygkJET+/v5q3769wsPDNXr06FwvkU9NTVVaWppSUlKyLKtQoYLWrl2rxx9/3Nx29uxZDR06VEFBQfL391fHjh21evVq8/KgoCD98ssv+uqrr+Tr66tdu3ZJkl5++WXt3btXP//8c57ecwAoagjdAFAEtWvXTv/880+Ws8WStHPnTo0dO1a9evXSd999p2XLlqlcuXLq3bu3kpKSNHv2bDVo0MB8mWlwcLB53fnz52vgwIG5htY9e/Zo165dmjdvnj7//HOZTCb1799fV69ezVPtgYGBmj59uqQbH/hv/lB9s5EjR2rFihV67bXXtH79ek2ePFm7du3Siy++KJPJZH7d+fPnNWfOHI0cOVJff/217r33Xo0aNSrXe6lXr16tt956S+3bt9fXX3+tTz75RKmpqXr++ef133//KTAw0Hxpd+/evbV9+3bdc889edq/m2UEzCpVqki6EfT69u2r06dP65NPPtEPP/yggQMHau7cuVq+fLmkG5f0t2vXTpUrV9b27dvVu3fvHPsfO3asunTporVr1+rZZ5/Vp59+qg0bNki68aVF3759FRcXp48++kiLFi3SH3/8oTVr1mTq46WXXpKbm5uWLVum9evXKywsTFOnTtX69etz3betW7dq//79WrRokZYvX6709HT169dPV65ckSTt3r1b/fr1U8WKFbVixQp9+umnSklJUWhoqM6fP5+prwULFuidd97R/PnzLXh3c3a7Y0CS5s2bpylTpqhjx45au3atpkyZou3bt+vVV1/N1NeFCxcUERGhZcuWqV+/ftlu7/z58/rjjz8KdI/2rcfe119/rcmTJ+u5557Txo0b9emnn8rBwUF9+/ZVcnJyjv1cv35dEydO1CuvvKK1a9fqgQce0PTp0zN9MWbpOufPn1ffvn3l6Oio5cuXa8aMGfriiy+ynV/iZuXLl1dAQIAWL16scePGaf/+/UpLS8v2tSkpKfrf//6nP/74Q2PHjtW6devUqVMn83Et3ThuPT099dhjj2n79u0KDAyUdOPvFE9PT0VERORaDwAUVYRuACiCMgLg2bNnsyw7cOCAXFxc9OSTT8rLy0t169bVpEmTtHDhQjk6Oqp8+fIqVaqUSpcurbvvvltlypQxr9uyZUu1b99elStXznHbV69e1bRp01S3bl35+/tr5MiROn/+vHbs2JGn2p2cnOTh4SFJKleuXLaXxsfFxWnt2rV66aWX1LlzZ3l7e+uhhx7S8OHDdfDgQf3xxx/m1545c0ajRo3Sfffdp5o1a6pPnz5KTU3VX3/9lWMNixYt0oMPPqiBAwfq3nvvlb+/v2bMmKHk5GSFh4fLyclJRqNRkuTq6qq7777bovtvTSaTjhw5orFjx+ruu+9Whw4dzMsWL16s+fPnq379+vLy8tLjjz+u+vXra9u2bZJuXNLv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de/eXQcOHLDHLkDSb7/9luWY8/Pzk6+vr3bt2pXtMblhwwbz+oyl/Wzbtk0tW7bUoEGDsizL7e/K9PR0vf/++2rXrp2aNGmiPn366OTJk+blCQkJev3119WyZUu1bt1ab7/9tpKTkwtln+5UuY3lxo0b9eSTTyowMFCPPvqovvjiC/Oy2bNnq169elmO0fj4eEnStWvXNHr0aD344INq1qyZXnvtNV24cKHQ9utOk9M4hoeHq27dulnGaf/+/ZI4JouanMZx5MiRWcawfv36euuttyRJw4cPV/369TMtb9y4sXl9xrEQmGBzTz31lGnkyJGmS5cumY4fP2565JFHTIsXL7Z3WcjG448/bho+fLgpMTHRdPr0aVNISIhpxIgRppMnT5p8fHxyXO+vv/4y+fn5mX766SdTcnKy6ZtvvjE1bNjQdPr06UKsHhl8fHxMJ0+ezNIeFxdnatSokenLL780JScnm3bs2GEKCAgw7d+/32QymUybNm0yNW7c2LR3715TUlKSacGCBaZWrVqZrly5Uti7gBzMmzfPNHDgQNOvv/5qatu2bY6vYyztZ+HChaZHHnnE1K1bN9Prr7+eadnt/q5cunSpqW3btqa///7bdPnyZdP48eNNTzzxhCk9Pd1kMplMr776qqlv376mc+fOmf777z/Ts88+a5owYUKh7+OdIrex3Ldvn8nf39/0448/mlJTU00//fSTqUGDBqbffvvNZDKZTLNmzTINGzYsx74nT55sCgkJMf3777+mCxcumF599VVTv379bLo/d6rcxnHNmjWm0NDQHNflmCw6chvHW6Wmppo6duxo+umnn0wmk8k0bNgw06xZs3J8PeNoe5zptrHIyEhFR0dryJAhcnd3V40aNRQWFqZVq1bZuzTc4tKlS/Lz89PgwYNVtmxZVa5cWU899ZR+//3326775Zdf6qGHHtJDDz0kZ2dnPfnkk/Lx8clyFhX2tW7dOtWoUUPPPPOMnJ2d1bJlSwUFBenLL7+UJK1atUohISFq2LChypQpoxdeeEGStGXLFnuWjf/z77//asmSJRo6dOhtX8tY2o+zs7NWr16t6tWrZ1l2u78rV61apbCwMN17771yc3PToEGDdPToUe3bt0/x8fGKiIjQoEGD5OnpqUqVKunll1/WmjVrlJqaWti7eUfIbSwTEhLUr18/tW/fXqVKldJD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RkZq//79WrBggXbs2KGpU6fmaRvnz5/X1KlTlZaWZq2y8yUqKkpPP/20jEajwsPDtW/fPq1cuVJGo1HdunXT/v377VofAAASoRsAUMINGDBAy5cv1/Hjx7NdfurUKfn6+uro0aPmtvfee089e/aUdOOs+H333adNmzYpKChIgYGBmjlzpiIjI/Xkk08qMDBQr776qlJTU83rJycna/DgwQoMDNTDDz+s77//3rwsISFBQ4YMUevWrRUYGKj+/fsrLi4uUy0rVqxQ06ZN9e2332Zb88qVK/XYY4+pYcOG6tChg9avXy9Jmjlzpj788EPt379f/v7+io2Nve37YzAYVKdOHb344ov68ccfze2RkZHq0aOHGjdurJYtW2rMmDFKTU1VfHy8HnzwQZlMJjVu3Fjh4eGaPXu2unbtan6/7r//fm3dulUdOnRQo0aN1KdPH128eFGSlJaWpvHjxyswMFBt2rTRd999p0ceeUTh4eGSpJ9++klPPPGEAgMD1bp1a02bNk3p6enZ1j5+/Hg99NBDGjJkiO6++24ZDAZVrVpVY8aM0RtvvKFSpUqZa/L19dW1a9fUpUsXzZkzJ1M/EydOVJ8+fSRJsbGxeumll9SsWTM1adJEQ4cOVWJiYp72DQCA7BC6AQAlWu3atdW1a1dNnDgx330kJSVp586d+u677zRmzBjNnz9fH374oT755BOFh4fr559/1ubNm82v/+abbxQcHKxdu3YpNDRUQ4YMMQfr4cOHKzk5Wd999522bdsmV1dXvfXWW5m2t3v3bm3evFkdO3bMUsvmzZs1bdo0TZgwQb///rtee+01vfnmmzp06JBef/119e/fXwEBAYqMjJSXl1ee9/HmLw0kadCgQWrevLl27dql1atXa8uWLeazyB9//LEk6ffff1dISEi279d3332nVatW6fvvv9ehQ4f0xRdfSJKWLVumDRs26IsvvtDatWu1YcMGnTlzxlzDoEGD9NZbb2nPnj367LPP9MMPP2R6bzOcO3dOe/bs0XPPPZft/oSFhal+/fpZ2jt06KCIiIhMbZs2bVLHjh1lMpn08ssv65577tFPP/2k77//XnFxcZmuAMht3wAAyA6hGwBQ4g0YMECHDh3KdCbXEunp6erRo4dcXFwUFBQkk8mkRx99VJ6enqpZs6Zq1aqlf/75x/z6gIAAtWvXTk5OTgoNDVXZsmX1yy+/6Ny5c9qyZYsGDRqkcuXKyc3NTUOGDNGOHTt09uxZ8/qdO3eWm5ubDAZDllpWr16txx9/XI0bN1bp0qUVHBysevXq6Ycffsj3vkVFRWnRokV64oknzO1ff/21XnrpJTk6OqpKlSpq0qSJDhw4kKc+09LS9MILL6hcuXKqXLmy7r//fh07dkyS9PPPP+vxxx9XnTp15OHhocGDByspKUmSdO3aNSUnJ8vV1VUGg0E1atTQxo0b1b59+yzbOHnypCSpRo0aFu1vhw4dFB0dbb4K4MCBAzp79qzat2+vyMhIHTlyRG+++aZcXFxUoUIFDRgwQGvXrpXJZLrtvgEAkJ1S9i4AAABbywi3kydP1gMPPJCvPjImJXN2dpYkVapUybzM2dlZ165dM/9cu3Zt858dHR3l5eWluLg4c1Ds3Llzpr4dHR11+vRpeXp6SpKqVKmSYx2nTp1S8+bNM7VVr149T5eSZ5g4caLeeecdSTdCt4uLi3r27KlXXnnF/Jpff/1Vc+fO1YkTJ3T9+nVdv35dHTp0yPM2qlatav6zi4uLkpOTJUlnz57VQw89ZF5Ws2ZNubm5SboxTq+88opCQ0MVEBCgVq1aKSQkJNsJ4TK+kMiYzE26MUt57969JUkmk0n33HNPli9avLy85O/vr4iICP3vf//Tjz/+qAceeEAeHh46efKk0tLS1KxZs0zrpKWl6cKFC7fdNwAAssOZbgDAHaFz586qVKmSFixYcNvXZjdBmIODQ64/326Zs7OzeXKzrVu3micyi4yM1F9//aWAgADzax0dHXPsO6fHXmV3VjwnN0+ktmDBAqWmpqpTp07me6CPHj2qgQMH6qmnntLOnTsVGRmpxx9/PM/9Szm/P+np6SpdunSOr3311VfNl3v//vvvCg4OznZCtBo1ashgMGQ6y5wxS3lkZKTGjx+f40Rvjz32mPkS8x9//FHBwcGSboyRq6trprHJGJ+ML0Ry2zcAALLDvxoAgDvG6NGj9cknn5jPOEv//8z1zWcrb16eHzdP2paWlqbY2FhVqlRJXl5ecnBw0KFDh8zLU1NTzfd754W3t3eWy5mPHTumatWq5avW1q1bq127dho1apT5EuqoqCg5OTnp+eefV5kyZWQymRQVFZWv/m9VoUKFTGfl//nnH126dMn8c0JCgipVqqTnnntOS5YsUYcOHfTNN99k6adcuXJq1aqVFi9enO12cpp8TZIeffRR7dmzR/v27VNsbKz58XHe3t66evVqpvFPTEzMdJYbAABLEboBAHeMevXqqXPnzpo5c6a5zdPTU+7u7tq4caPS0tK0fft27d27t0Db2bNnj3bs2KHU1FStXLlSycnJat26tdzd3RUcHKz33ntP//33n5KTkzVjxgz17t3bHHhvp1OnTlq3bp327t2r1NRUhYeH68iRI9lOupZXI0aMUHR0tFatWiXpxiXYycnJioqK0sWLFzVt2jQ5OTnpzJkzMplM5jP2x48fz/IM9Ntp1qyZ1q1bp+PHj+vy5ct6//335erqKkn6888/9dhjj2n//v0ymUw6d+6cjh8/Lm9v72z7evvtt7V//34NGjRIp06dknQjtH/55ZeaMWNGpqsHbubl5aUGDRro3Xff1UMPPaSyZctKknx8fBQYGKhJkybp/PnzunTpksaMGaOhQ4datI8AANyM0A0AuKO8/vrrme4DdnR01JgxY/TVV1+pcePG+vrrr3OcETuvunbtqi+++EJNmzbV0qVL9f7778vDw0OSNGrUKFWvXl0dO3bUAw88oL///lsffvhhni8P79ixo/r166ehQ4eqWbNmWrFihRYvXmzxhGI3MxqNeuONNzRt2jTFxcUpMDBQzz33nEJDQ9WxY0d5eXlpxIgROnz4sAYNGqR69eopMDBQzzzzjD7//HOLtvXCCy+ocePG6tSpk5555hl17txZLi4ucnBwMD9C7fXXX1fDhg311FNPqWHDhjmOR61atbRmzRqVKVNGPXr0UEBAgDp06KDvv/9eI0aM0IwZM3Kso0OHDvr999+zfFkxffp0mUwmtWvXTg8//LDS0tI0ZcoUi/YRAICbGUx5/WodAADAClJSUuTk5CTpxuX1jRo10kcffaQWLVrYuTIAAKyPM90AAKDQfP3112rbtq2OHz+u1NRULViwQO7u7vL397d3aQAA2ASPDAMAAIXmySef1NGjR/X8888rMTFRtWvX1ty5c82PDQMAoKTh8nIAAAAAAGyEy8sBAAAAALARQjcAAAAAADZC6AYAAAAAwEYI3QAAAAAA2AihGwAAAAAAGyF0AwAAAABgI4RuAAAAAABshNANAAAAAICNELoBAAAAALCR/wdF29Ehb/kHxAAAAABJRU5ErkJggg==\n"},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<Figure size 1000x400 with 1 Axes>"],"image/png":"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4sSJAu2Tnp6ut956S82aNVNwcLBeeOEFRUVF3XaIfGpqqgwGg65evZpj3ciRI/XRRx9lC9y3eu3Xrl2rAQMGSJLatWungQMHSpIaNGigli1bas6cOZa83ADgcIRuAHCwdu3a6eTJkzmuFkvSzp07NXnyZD311FPauHGjVqxYobJly2rIkCFKSUnRnDlzVLduXQUHB2vHjh3q3Lmzed+FCxdq5MiRtwytu3fv1q5du7RgwQKtWrVKJpNJw4cPV3JyskW1BwcHa+bMmZKu3ysbHh6e63YTJ07UZ599pv/+97/atGmT3nnnHe3atUvPPvusbrzL6cKFC5o7d64mTpyodevWqXr16po0adIt76UODw/Xq6++qvbt22vdunX65JNPlJ6erkGDBunMmTMKDg42D+0eMmSIduzYoXvvvdei87tRVsC87777JEkmk0lDhw5VXFycPvnkE3377bcaOXKk5s2bp08//VSS9Nprr6ldu3aqVKmSduzYkW2Y8c0mT56s3r17a/369erbt6+WLVumzZs3S7r+pcXQoUNlNBq1dOlSLVmyRH/99Ze+/PLLbG0899xz8vDw0IoVK7Rp0yYNHjxY7777rjZt2nTLc/vpp5+0d+9eLVmyRJ9++qkyMzM1bNgw832zv//+u4YNG6aKFSvqs88+07Jly5SWlqbQ0FBduHAhW1uLFi3S22+/rYULF97ymAaDQV26dNG6deuyhcqNGzfK09PT/GVRltTUVA0aNEhRUVGaNWuWNm3apGeeeUZLlizR9OnTJUldu3bVnj17cgTmTZs2qVWrVqpQoUKOOr7++muNGzdODRs21Nq1azV//nwdO3ZMgwcPVlpaWp71b926VWXKlFGTJk1ueZ55OXTokE6ePKkvv/xS3bt3t6g/5WX16tVKSUnRsmXLtGDBAh08eFBTpkwp0D5z5szRZ599pueff15r165VkyZNNHr06Nue10MPPaS0tDT169dP69aty9E/bnS7175z584aM2aMJOmLL77IFrJDQkK0d+/e2345AgCFAaEbABwsKwDeeD9oln379snNzU3dunWTr6+vatWqpalTp2rx4sVydnZWuXLlVKJECZUsWVL33HNPtntFW7Roofbt26tSpUp5Hjs5OVnTp09XrVq1FBQUpIkTJ+rChQv65ZdfLKrdxcVFZcqUkSSVLVs216HxRqNR69ev13PPPafHH39c/v7+at26tcaPH6/9+/frr7/+Mm979uxZTZo0SY0aNdL999+vp59+Wunp6Tpw4ECeNSxZskQPP/ywRo4cqerVqysoKEizZs3S1atXtXbtWrm4uMjb21vS/w31dXZ2tuj8pOvh+vDhw5o8ebLuuecedezY0bzu448/1sKFC1WnTh35+vrqscceU506dfTzzz9Luj6k39XV1Tyk/FbDmjt37qxHHnlEfn5+Gj58uEqWLGm+2vzHH38oNjZWEyZMUNOmTVWrVi19+OGH2b4cOX/+vOLi4tShQwfVrFlTlStXVp8+ffT555/fNhgmJydr6tSpqlmzpurXr69x48Zl6weLFy+Wr6+vpk+frho1aigoKEgzZ85UUlKSPv/88xzn0axZM4uGVHfr1k1xcXH69ddfzcvWrl2rzp0753iPtm7dqhMnTmjatGlq0aKF/P391a9fP/Xp00dr1qxRWlqaOnbsqBIlSmjLli3m/Y4fP66oqCh179491xoWLlyoJk2a6LXXXlPVqlXVuHFjTZs2TceOHdO3336bZ+2///67goODrepLNzpz5owmT56satWqmW/9uF1/you7u7vGjRunatWqqXnz5goJCVFkZGSB9vnqq6/Uvn17/ec//9H999+vwYMHWzSUu3Xr1po8ebIuXLigV155RQ8++KC6dOmit99+2zz6JMvtXvtSpUqZ50/w8vLKNky+cePGkq7/bgBAYUfoBgAHyxoam9sf7y1btlRmZqb69u2rVatW6fjx43J3d1eDBg1ue09kvXr1bnvsevXqydXV1fxz1lDlY8eOWXMKt7Rv3z6ZTCbzH8lZgoODJSlboHZ3d1dAQID556wQn5iYmGvbSUlJOnHiRI62vb295efnd8uwnpfvvvtOwcHB5v+CgoLUvXt3lS9fXitXrjQHZ4PBoMTERE2dOlUhISFq1KiRgoODFRkZaZ64yhoNGjQw/3+JEiVUpkwZ83nHxMRIknmYvHT9C48bh/57eXkpODhYkydP1qxZs/T7778rPT1dderUuW0ADgoKytYP6tatK0mKjY2VJO3du1fNmzfP1ke9vb1Vs2bNHK+xJf0uS61atbINVz58+LD279+vrl275tg2MjJSrq6u2V4D6Xo/SklJ0bFjx1S+fHm1atUqW1jetGmTPDw8ch2unpSUpGPHjuW4haJ27doqV67c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FLorVqyowYMHS5IyMjL04osv2rMmAMBdIj4+XinJKQW6t/xAxAFtnro5323ceG86oRsAANia1bOXjxw5UocPH9a3336r2NhYSZK/v78ee+wx+flxXyAAwHoFubfceMhY4DYAAADsxerpZjdt2qQePXroxx9/VFpamtLS0rR161Z16dJFf/75pz1qBAAAAACgSLL6SvfcuXP13nvvqXPnztmWr127Vu+9954+//xzmxUHAAAAAEBRZvWV7n///VePPvpojuXdunXTsWPHbFIUAAAAAADFgdWh+7777sv1Od379+9XhQoVbFIUAAAAAADFgdXDywcNGqShQ4eqa9euql69uiTp2LFj+uabbzRs2DCbFwgAAAAAQFFldeju16+fKlasqC+//FK7d+9WWlqa/P399cYbb+S4zxsAAAAAgLuZ1aFbkkJCQhQSEmLrWgAAAAAAKFasvqcbAAAAAABYhtANAAAAAICdELoBAAAAALATq0P3pk2b7FEHAAAAAADFjtWh+4033lBycrI9agEAAAAAoFixevbyl156SRMnTtTjjz+u++67T87OztnW33///TYrDgAAAACAoszq0P3GG29Iyj7M3GAwyGQyyWAwKCoqynbV3cbu3bv14osvatq0aXr44Yfv2HEBAAAAALCE1aF727Zt9qjDavHx8Vq0aJGCg4MdXQoAAAAAALmy+p5uX19f+fr6qlSpUrp48aL556z/7pQyZcpo7ty58vT0vGPHBAAAAADAGlaHbqPRqKefflotW7ZUv379JElnz55V165dderUqXwV8fPPP6tFixYaNWpUtuWxsbEaOnSomjVrprZt22r69OnKzMyUJLm4uKhkyZL5Oh4AAAAAAHeC1aH7zTfflJeXl7Zv3y4np+u7e3l5qVWrVnrrrbesLmDJkiV66623VKVKlRzrRowYIR8fH0VERCgsLEwRERFatmyZ1ccAAAAAAMARrA7dv/32myZPnqx7771XBoNBklSiRAmNHDlSe/bssboAV1dXhYeH5wjdkZGRio6O1pgxY+Tp6amqVatq8ODBWrNmjdXHAAAAAADAEayeSM3NzU0mkynH8kuXLikjI8PqAgYNGpTr8v3798vX11dly5Y1L6tbt66OHz+upKQkeXh4WHWczMxM89D0wii31xQAioKsz6/MzEzzl7GWKkyfy4X934m7VdZ7kp/+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\n"},"metadata":{}}]},{"cell_type":"code","source":["# ============================================================================ #\n","# CELL 3: Model Helpers (CONSOLIDATED)\n","# ============================================================================ #\n","logger.info(\"+++ Cell 3: Defining ALL Model Helpers +++\")\n","\n","# --- Retraction Factory ---\n","class RetractionFactory:\n","    _registry = {}\n","    @classmethod\n","    def register(cls, name):\n","        def decorator(fn): cls._registry[name] = fn; return fn\n","        return decorator\n","    @classmethod\n","    def get(cls, name):\n","        if name not in cls._registry: raise KeyError(f\"Unknown retraction '{name}'. Available: {list(cls._registry.keys())}\")\n","        return cls._registry[name]\n","# --- Register Retractions ---\n","@RetractionFactory.register(\"orthonormal\")\n","def _retract_qr(U: np.ndarray, V: np.ndarray) -> np.ndarray:\n","    \"\"\"QR-based retraction.\"\"\"\n","    if np.linalg.norm(V) < 1e-12: return U.astype(np.float32)\n","    UV = U + V\n","    if not np.isfinite(UV).all(): logger.warning(\"OrthRetraction: Input U+V non-finite.\"); return U.astype(np.float32)\n","    try:\n","        Q, R_qr = np.linalg.qr(UV, mode='reduced') # Use 'reduced'\n","        if Q.shape[1] < U.shape[1]:\n","             pad_width = U.shape[1] - Q.shape[1]; Q = np.pad(Q, ((0, 0), (0, pad_width)), mode='constant')\n","             logger.warning(f\"OrthRetraction: Padded Q\")\n","        return Q.astype(np.float32)\n","    except Exception as e: logger.error(f\"OrthRetraction failed: {e}\"); return U.astype(np.float32)\n","@RetractionFactory.register(\"cayley\")\n","def _retract_cayley(U: np.ndarray, V: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n","    \"\"\" Simple Cayley approx using QR of ambient step. \"\"\"\n","    return _retract_qr(U, alpha * V)\n","@RetractionFactory.register(\"projection\")\n","def _retract_projection(U: np.ndarray, V: np.ndarray) -> np.ndarray:\n","    \"\"\" Projection (polar decomposition) retraction. \"\"\"\n","    U64 = U.astype(np.float64, copy=False); V64 = V.astype(np.float64, copy=False)\n","    Z = U64 + V64; G = Z.T @ Z\n","    try:\n","        s, P = np.linalg.eigh(G); s_safe = np.maximum(s, 1e-12)\n","        s_inv_sqrt = 1.0 / np.sqrt(s_safe); G_mhalf = P @ np.diag(s_inv_sqrt) @ P.T\n","        result = (Z @ G_mhalf).astype(np.float32)\n","        if result.shape != U.shape: logger.warning(f\"Projection Retraction Warning: Shape mismatch. Falling back to QR.\"); return _retract_qr(U, V)\n","        return result\n","    except Exception as e: logger.warning(f\"Projection Retraction Warning: {e}. Falling back to QR.\"); return _retract_qr(U, V)\n","# --- Get the chosen retraction function ---\n","R_fn = RetractionFactory.get(RETRACTION_NAME)\n","if RANK_MPI == 0: logger.info(f\"Using Retraction: {RETRACTION_NAME}\")\n","def LOSSANDGRAD_TOTAL_DERIVATIVE(\n","    U: np.ndarray,\n","    X_local: sparse.csc_matrix,\n","    mask_coo_global: sparse.coo_matrix,\n","    N_users: int,\n","    M_movies: int,\n","    *,\n","    user_data_override: Optional[Dict[int, Dict[str, np.ndarray]]] = None,\n","    return_W: bool = False,\n",") -> Union[\n","    Tuple[float, np.ndarray],\n","    Tuple[float, np.ndarray, np.ndarray, np.ndarray]\n","]:\n","    \"\"\"\n","    Computes the total profiled loss L(U, W*(U)) and its Euclidean total derivative dL/dU.\n","    Solves for W*(U) using the closed-form expression.\n","    Optionally returns the local W*(U) and local gradient w.r.t. W.\n","\n","    Args:\n","        U (np.ndarray): Current movie factor matrix, shape (M_movies x RANK), float64.\n","        X_local (sparse.csc_matrix): Local partition of the training data matrix (M_movies x N_users).\n","        mask_coo_global (sparse.coo_matrix): Global mask matrix (COO) indicating observed entries.\n","        N_users (int): Total number of users globally.\n","        M_movies (int): Total number of movies globally.\n","        user_data_override (dict, optional): Override for user_data_arrays if needed.\n","        return_W (bool): If True, also return W_local and local gradient w.r.t. W.\n","\n","    Returns:\n","        If return_W=False:\n","            (total_loss, dL_dU)\n","        If return_W=True:\n","            (total_loss, dL_dU, local_grad_W, W_local)\n","        total_loss is a scalar float64,\n","        dL_dU is an (M_movies x RANK) float64 array,\n","        local_grad_W is an (RANK x N_users) float64 array,\n","        W_local is an (RANK x N_users) float64 array.\n","    \"\"\"\n","    U = U.astype(np.float64, copy=False)\n","    M, r = U.shape\n","\n","    # 1) Solve W*(U) for the local columns\n","    W_local = WCLOSEDEFFICIENT(\n","        U=U,\n","        N_users=N_users,\n","        user_data_override=user_data_override\n","    )  # shape (r x N_users), float64\n","\n","    # 2) Observed-data term for local slice\n","    local_obs_loss = 0.0\n","    local_grad_obs_term_U = np.zeros_like(U, dtype=np.float64)\n","    local_grad_obs_term_W = np.zeros_like(W_local, dtype=np.float64)\n","\n","    if X_local.nnz and mask_coo_global.nnz:\n","        if not sparse.isspmatrix_coo(mask_coo_global):\n","            mask_coo_global = mask_coo_global.tocoo()\n","\n","        r_ok = (mask_coo_global.row < X_local.shape[0]) & (mask_coo_global.row >= 0)\n","        c_ok = (mask_coo_global.col < X_local.shape[1]) & (mask_coo_global.col >= 0)\n","        sel = r_ok & c_ok\n","        rows = mask_coo_global.row[sel]\n","        cols = mask_coo_global.col[sel]\n","\n","        if rows.size:\n","            R_omega = X_local[rows, cols].A1.astype(np.float64)\n","            mask_loc = sparse.coo_matrix(\n","                (np.ones_like(rows, dtype=np.uint8), (rows, cols)),\n","                shape=X_local.shape,\n","                dtype=np.uint8,\n","            )\n","            UW_sparse_local = sparse_product(U, W_local, mask_loc)\n","            UW_omega = UW_sparse_local.data.astype(np.float64)\n","\n","            good = np.isfinite(UW_omega) & np.isfinite(R_omega)\n","            if not np.all(good):\n","                bad_count = (~good).sum()\n","                logger.warning(\n","                    \"Rank %d: filtered %d non-finite preds/targets locally\",\n","                    RANK_MPI,\n","                    bad_count\n","                )\n","                UW_omega = UW_omega[good]\n","                R_omega = R_omega[good]\n","                rows = rows[good]\n","                cols = cols[good]\n","\n","            if UW_omega.size:\n","                err_omega = UW_omega - R_omega\n","                local_obs_loss = 0.5 * np.dot(err_omega, err_omega)\n","\n","                E_coo_local = sparse.coo_matrix(\n","                    (err_omega, (rows, cols)),\n","                    shape=X_local.shape\n","                )\n","                local_grad_obs_term_U = E_coo_local @ W_local.T\n","                local_grad_obs_term_W = U.T @ E_coo_local.tocsc()\n","\n","    def _allreduce(arr, op=MPI.SUM):\n","        if COMM and SIZE_MPI > 1:\n","            arr_np = np.asarray(arr, dtype=np.float64)\n","            recv = np.zeros_like(arr_np)\n","            COMM.Allreduce(arr_np, recv, op=op)\n","            if arr_np.ndim == 0:\n","                return float(recv)\n","            return recv\n","        if np.isscalar(arr):\n","            return float(arr)\n","        return np.asarray(arr, dtype=np.float64)\n","\n","    global_obs_loss = _allreduce(local_obs_loss)\n","    global_grad_obs_term_U = _allreduce(local_grad_obs_term_U)\n","    global_grad_obs_term_W = _allreduce(local_grad_obs_term_W)\n","\n","    U_fro_sq = np.sum(U**2)\n","    local_W_fro_sq = np.sum(W_local**2)\n","    global_W_fro_sq = _allreduce(local_W_fro_sq)\n","\n","    total_loss = (\n","        global_obs_loss\n","        + 0.5 * LAM_SQ * U_fro_sq\n","        + 0.5 * LAM_SQ * global_W_fro_sq\n","    )\n","\n","    dL_dU = global_grad_obs_term_U + LAM_SQ * U\n","    local_gW0 = local_grad_obs_term_W\n","\n","    if not np.isfinite(total_loss):\n","        logger.warning(\"Rank %d: Non-finite loss clamped.\", RANK_MPI)\n","        total_loss = np.finfo(np.float64).max\n","    if not np.isfinite(dL_dU).all():\n","        logger.warning(\"Rank %d: Non-finite dL/dU replaced with zeros.\", RANK_MPI)\n","        dL_dU = np.nan_to_num(dL_dU)\n","    if return_W and not np.isfinite(local_gW0).all():\n","        logger.warning(\"Rank %d: Non-finite local ∇W replaced with zeros.\", RANK_MPI)\n","        local_gW0 = np.nan_to_num(local_gW0)\n","    if return_W and not np.isfinite(W_local).all():\n","        logger.warning(\"Rank %d: Non-finite W_local replaced with zeros.\", RANK_MPI)\n","        W_local = np.nan_to_num(W_local)\n","\n","    if return_W:\n","        return float(total_loss), dL_dU, local_gW0, W_local\n","    else:\n","        return float(total_loss), dL_dU\n","\n","# --- Other Manifold Helpers ---\n","def ProjTangent(U: np.ndarray, G: np.ndarray) -> np.ndarray:\n","    \"\"\"Project G onto tangent space at U (Grassmann).\"\"\"\n","    return (G - U @ (U.T @ G)).astype(np.float32)\n","def LogMapApprox(U_base: np.ndarray, U_target: np.ndarray) -> np.ndarray:\n","    \"\"\"Approximate inverse retraction (log map).\"\"\"\n","    return ProjTangent(U_base, U_target - U_base)\n","def RegularizeGradChordalApprox(U: np.ndarray, U_old: np.ndarray, kappa: float) -> np.ndarray:\n","    \"\"\"Approximate gradient of distance regularization term.\"\"\"\n","    U = U.astype(np.float32); U_old = U_old.astype(np.float32);\n","    if REG_DISTANCE == \"euclid\": S = U.T @ U_old; grad_ambient = U @ (S - S.T); return kappa * ProjTangent(U, grad_ambient)\n","    elif REG_DISTANCE == \"retraction\": v = LogMapApprox(U, U_old); return -kappa * v\n","    else: raise ValueError(f\"Unknown REG_DISTANCE type: {REG_DISTANCE}\")\n","\n","# --- RMSE Evaluation ---\n","def evaluate_rmse_with_biases(\n","    U: np.ndarray, W: np.ndarray,\n","    user_bias: np.ndarray, movie_bias: np.ndarray, global_mean: float,\n","    probe_users_mapped: np.ndarray, probe_movies_mapped: np.ndarray, probe_ratings_true: np.ndarray # Now contains true ratings\n",") -> float:\n","    \"\"\"Computes RMSE on the validation set including bias terms and clamping.\"\"\"\n","    if probe_ratings_true.size == 0: return np.nan # Check if validation set is empty\n","    U = U.astype(np.float64, copy=False); W = W.astype(np.float64, copy=False)\n","    user_bias = user_bias.astype(np.float64, copy=False); movie_bias = movie_bias.astype(np.float64, copy=False)\n","    local_sum_sq_err = 0.0; local_count = 0\n","    try:\n","        if M_movies_active == 0 or N_users_active == 0: return np.nan\n","        if probe_movies_mapped.size > 0 and (probe_movies_mapped.max() >= M_movies_active or probe_movies_mapped.min() < 0): return np.nan\n","        if probe_users_mapped.size > 0 and (probe_users_mapped.max() >= N_users_active or probe_users_mapped.min() < 0): return np.nan\n","        dot_prods = np.array([np.dot(U[m, :], W[:, u]) for m, u in zip(probe_movies_mapped, probe_users_mapped)], dtype=np.float64)\n","        preds_raw = global_mean + user_bias[probe_users_mapped] + movie_bias[probe_movies_mapped] + dot_prods\n","        preds_clamped = np.clip(preds_raw, 1.0, 5.0)\n","        if not np.isfinite(preds_clamped).all(): preds_clamped = np.nan_to_num(preds_clamped, nan=global_mean)\n","        if not np.isfinite(probe_ratings_true).all(): probe_ratings_true = np.nan_to_num(probe_ratings_true)\n","        squared_errors = (preds_clamped - probe_ratings_true)**2\n","        local_sum_sq_err = np.sum(squared_errors)\n","        local_count = len(squared_errors)\n","    except IndexError as e: logger.error(f\"IndexError during biased RMSE: {e}\"); return np.nan\n","    except Exception as e: logger.error(f\"Error during biased RMSE: {e}\"); return np.nan\n","    # --- MPI Reduction for RMSE ---\n","    if COMM and SIZE_MPI > 1:\n","        global_sum_sq_err_buf = np.array(local_sum_sq_err, dtype=np.float64); global_count_buf = np.array(local_count, dtype=np.int64)\n","        global_sum_sq_err = np.array(0.0, dtype=np.float64); global_count = np.array(0, dtype=np.int64)\n","        COMM.Allreduce(global_sum_sq_err_buf, global_sum_sq_err, op=MPI.SUM); COMM.Allreduce(global_count_buf, global_count, op=MPI.SUM)\n","        if global_count > 0: mean_squared_error = global_sum_sq_err / global_count\n","        else: return np.nan\n","    else: # Serial case\n","        if local_count > 0: mean_squared_error = local_sum_sq_err / local_count\n","        else: return np.nan\n","    mean_squared_error = max(0.0, mean_squared_error); rmse = np.sqrt(mean_squared_error)\n","    return float(rmse) if np.isfinite(rmse) else np.nan\n","\n","# --- RMSE Helper for SoftImpute (No Biases) ---\n","def evaluate_rmse_low_rank(U, S, V, probe_movies_mapped, probe_users_mapped, probe_ratings_true, use_gpu=False):\n","    \"\"\"Computes RMSE for low-rank model X = USV^T against true ratings.\"\"\"\n","    if probe_ratings_true.size == 0: return np.nan\n","    xp = cp if use_gpu else np\n","    try:\n","        if M_movies_active == 0 or N_users_active == 0: return np.nan\n","        if probe_movies_mapped.size > 0 and (probe_movies_mapped.max() >= M_movies_active or probe_movies_mapped.min() < 0): return np.nan\n","        if probe_users_mapped.size > 0 and (probe_users_mapped.max() >= N_users_active or probe_users_mapped.min() < 0): return np.nan\n","        U_dev = xp.asarray(U); S_dev = xp.asarray(S); V_dev = xp.asarray(V)\n","        probe_movies_dev = xp.asarray(probe_movies_mapped); probe_users_dev = xp.asarray(probe_users_mapped)\n","        probe_ratings_dev = xp.asarray(probe_ratings_true)\n","        term2 = S_dev * V_dev[probe_users_dev, :]\n","        preds_raw = xp.sum(U_dev[probe_movies_dev, :] * term2, axis=1)\n","        preds_clamped = xp.clip(preds_raw, 1.0, 5.0)\n","        if not xp.isfinite(preds_clamped).all(): preds_clamped = xp.nan_to_num(preds_clamped, nan=3.0)\n","        if not xp.isfinite(probe_ratings_dev).all(): probe_ratings_dev = xp.nan_to_num(probe_ratings_dev)\n","        mse_dev = xp.mean((preds_clamped - probe_ratings_dev)**2)\n","        mse = float(cp.asnumpy(mse_dev) if use_gpu else mse_dev)\n","        rmse = np.sqrt(mse) if mse >= 0 else np.nan\n","    except IndexError as e: logger.error(f\"IndexError during low-rank RMSE: {e}\"); return np.nan\n","    except Exception as e: logger.error(f\"Error during low-rank RMSE: {e}\"); return np.nan\n","    return float(rmse) if np.isfinite(rmse) else np.nan\n","\n","# --- Initialization ---\n","def initialize_factors_and_biases(M: int, N: int, R: int, rng: Generator, scale: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n","    \"\"\"Initializes U, W, user_bias, movie_bias.\"\"\"\n","    U = None; W = None; user_bias = None; movie_bias = None\n","    if RANK_MPI == 0:\n","        U = rng.standard_normal(size=(M, R)).astype(np.float64) * scale\n","        W = rng.standard_normal(size=(R, N)).astype(np.float64) * scale\n","        user_bias = np.zeros(N, dtype=np.float64)\n","        movie_bias = np.zeros(M, dtype=np.float64)\n","        if M >= R: U_orth, _ = np.linalg.qr(U, mode='reduced'); U = U_orth.astype(np.float64)\n","        else: logger.warning(f\"M ({M}) < R ({R}). Cannot orthonormalize U.\")\n","    if COMM and SIZE_MPI > 1:\n","        if RANK_MPI != 0: U = np.empty((M, R), dtype=np.float64); W = np.empty((R, N), dtype=np.float64); user_bias = np.empty(N, dtype=np.float64); movie_bias = np.empty(M, dtype=np.float64)\n","        COMM.Bcast(U, root=0); COMM.Bcast(W, root=0); COMM.Bcast(user_bias, root=0); COMM.Bcast(movie_bias, root=0)\n","    return U, W, user_bias, movie_bias\n","\n","# --- Initial State Recorder ---\n","def record_initial_state_biased(U, W, user_bias, movie_bias, loss_args_biased, eval_args_biased):\n","    \"\"\"Computes and logs initial state for biased models.\"\"\"\n","    current_loss, gU0, gW0, gBu0, gBi0 = loss_and_grad_serial_with_biases(U, W, user_bias, movie_bias, *loss_args_biased)\n","    current_rmse = evaluate_rmse_with_biases(U, W, user_bias, movie_bias, *eval_args_biased)\n","    gU_proj_0 = ProjTangent(U, gU0)\n","    grad_norm_U_riemann = np.linalg.norm(gU_proj_0)\n","    grad_norm_W = np.linalg.norm(gW0); grad_norm_Bu = np.linalg.norm(gBu0); grad_norm_Bi = np.linalg.norm(gBi0)\n","    if RANK_MPI == 0: logger.info(\n","        f\"Epoch 00 (Init): Loss={current_loss:.4e}, RMSE={current_rmse:.4f}, \"\n","        f\"||Proj gU||={grad_norm_U_riemann:.2e}, ||gW||={grad_norm_W:.2e}, \"\n","        f\"||gBu||={grad_norm_Bu:.2e}, ||gBi||={grad_norm_Bi:.2e}\"\n","    )\n","    if not np.isfinite(current_loss): raise ValueError(\"Initial loss is not finite.\")\n","    return current_loss, current_rmse, gU0, gW0, gBu0, gBi0\n","\n","# --- Armijo Line Search ---\n","def ArmijoLineSearchRiemannian(\n","    U: np.ndarray, G_euclidean: np.ndarray, loss_args: tuple, current_loss: float,\n","    lr_init: float, beta: float, sigma: float, max_ls_iter: int = 20\n",") -> Tuple[float, np.ndarray, float]:\n","    \"\"\"Performs Armijo line search using retraction.\"\"\"\n","    lr = lr_init\n","    G_proj = ProjTangent(U, G_euclidean)\n","    G_proj_norm_sq = np.linalg.norm(G_proj)**2\n","    if G_proj_norm_sq < 1e-14: return 0.0, U, current_loss\n","    for ls_iter in range(max_ls_iter):\n","        step_vec = -lr * G_proj\n","        U_next = R_fn(U, step_vec) # Use chosen retraction\n","        if not np.isfinite(U_next).all(): lr *= beta; continue\n","        try:\n","            W_ls, ub_ls, mb_ls, *rest_args = loss_args\n","            loss_next, _, _, _, _ = loss_and_grad_serial_with_biases(U_next, W_ls, ub_ls, mb_ls, *rest_args)\n","        except Exception as e: logger.error(f\"Armijo LS Error: {e}\"); return 0.0, U, current_loss\n","        if not np.isfinite(loss_next): lr *= beta; continue\n","        required_decrease = sigma * lr * G_proj_norm_sq\n","        actual_decrease = current_loss - loss_next\n","        if actual_decrease >= required_decrease - 1e-9: return lr, U_next, loss_next\n","        lr *= beta\n","        if lr < 1e-14: break\n","    logger.debug(\"Armijo LS failed.\"); return 0.0, U, current_loss\n","\n","# --- Adaptive Stopping Check ---\n","def should_stop_subproblem(G_proj, step_vec):\n","    \"\"\"Return True if both criteria are already small.\"\"\"\n","    grad_norm_proj = np.linalg.norm(G_proj)\n","    step_norm = np.linalg.norm(step_vec)\n","    stop = (grad_norm_proj < ETA_GRAD and step_norm < ETA_DIST)\n","    return stop\n","\n","# --- Adaptive Kappa Update ---\n","def update_kappa_adaptive(kappa_prev, h_hist, dist_hist, U_local,\n","                          gamma=2.0, window=3,\n","                          kappa_min=1e-4, kappa_max=1e12):\n","    \"\"\" Adaptive kappa update using local curvature estimate. \"\"\"\n","    if U_local.shape[1] == 0: return kappa_min # Handle empty matrix case\n","    v = GLOBAL_RNG.standard_normal(size=(U_local.shape[1], 1)).astype(U_local.dtype)\n","    v /= np.linalg.norm(v) + 1e-12\n","    U_local_64 = U_local.astype(np.float64); v_64 = v.astype(np.float64)\n","    lambda_max_sq = 0.0\n","    for _ in range(2): # 2 power iterations on U^T U\n","        Av = U_local_64.T @ (U_local_64 @ v_64)\n","        lambda_max_sq = v_64.T @ Av\n","        v_norm = np.linalg.norm(Av); v_64 = Av / (v_norm + 1e-12)\n","    L_local = np.sqrt(max(0.0, lambda_max_sq.item()))\n","    target_ratio = 0.9; target = target_ratio * L_local\n","    kappa_new = np.clip(target, kappa_min, kappa_max)\n","    return float(kappa_new)\n","\n","# --- OT Demo Helper ---\n","def run_barycentre_demo(n_grid=200, reg=1e-1, rng_seed=0):\n","    \"\"\" POT demo: 3 one-dimensional Gaussians -> entropic Wasserstein barycenter \"\"\"\n","    if not OT_AVAILABLE: return None\n","    grid = np.linspace(-8.0, 8.0, n_grid)\n","    M = ot.dist(grid.reshape(-1, 1), grid.reshape(-1, 1)) ** 2\n","    means = np.array([-3.0, 0.0, 3.0]); sigmas = np.array([0.5, 1.0, 0.7])\n","    sources = np.vstack([np.exp(-0.5 * ((grid - m) / s) ** 2) / (s * np.sqrt(2 * np.pi)) for m, s in zip(means, sigmas)]).T\n","    sources /= sources.sum(axis=0, keepdims=True)\n","    bary, log = ot.bregman.barycenter(sources, M, reg, weights=None, numItermax=1000, stopThr=1e-7, log=True)\n","    return {'grid': grid, 'sources': sources, 'barycenter': bary, 'log': log}\n","\n","\n","logger.info(\"Cell 3: Model Helpers Defined.\")"],"metadata":{"id":"SH7Hi7V4MDN3","executionInfo":{"status":"ok","timestamp":1746544914020,"user_tz":240,"elapsed":77,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}}},"execution_count":8,"outputs":[]},{"cell_type":"code","source":["\n","\n","# ============================================================================ #\n","# CELL 4: Non-Convex Solvers (SVRG, ALS, Euclidean GD) - Renumbered\n","# ============================================================================ #\n","logger.info(\"+++ Cell 4: Defining Non-Convex Solvers +++\")\n","# --- Loss/Gradient Functions ---\n","def loss_and_grad_serial_with_biases(\n","    U: np.ndarray, W: np.ndarray, user_bias: np.ndarray, movie_bias: np.ndarray,\n","    global_mean: float,\n","    rows_idx: np.ndarray, cols_idx: np.ndarray, vals_true_centered: np.ndarray, # Centered ratings\n","    n_movies_func: int, n_users_func: int, rank_func: int,\n","    lambda_sq_func: float, lambda_bias_func: float\n",") -> Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n","    \"\"\" Computes loss and gradients for U, W, user_bias, movie_bias. \"\"\"\n","    # ... (implementation from v11) ...\n","    U = U.astype(np.float64, copy=False); W = W.astype(np.float64, copy=False)\n","    user_bias = user_bias.astype(np.float64, copy=False); movie_bias = movie_bias.astype(np.float64, copy=False)\n","    if vals_true_centered.size == 0: return 0.0, np.zeros_like(U), np.zeros_like(W), np.zeros_like(user_bias), np.zeros_like(movie_bias)\n","    try:\n","        W_cols = W[:, cols_idx]; U_rows = U[rows_idx, :]\n","        dot_prods = np.sum(U_rows * W_cols.T, axis=1)\n","        preds_residual = user_bias[cols_idx] + movie_bias[rows_idx] + dot_prods\n","    except IndexError as e: logger.error(f\"Indexing error in loss_and_grad_serial_with_biases - {e}\"); raise\n","    valid_mask = np.isfinite(preds_residual) & np.isfinite(vals_true_centered)\n","    if not np.all(valid_mask):\n","        logger.warning(f\"Filtering {np.sum(~valid_mask)} non-finite values in loss_and_grad_serial_with_biases.\")\n","        rows_idx_filt = rows_idx[valid_mask]; cols_idx_filt = cols_idx[valid_mask]\n","        vals_true_filt = vals_true_centered[valid_mask]; preds_filt = preds_residual[valid_mask]\n","        if preds_filt.size == 0: return np.inf, np.zeros_like(U), np.zeros_like(W), np.zeros_like(user_bias), np.zeros_like(movie_bias)\n","    else:\n","        rows_idx_filt, cols_idx_filt, vals_true_filt, preds_filt = rows_idx, cols_idx, vals_true_centered, preds_residual\n","    errors = preds_filt - vals_true_filt\n","    loss_obs = 0.5 * np.sum(errors**2)\n","    loss_reg_U = 0.5 * lambda_sq_func * np.sum(U**2); loss_reg_W = 0.5 * lambda_sq_func * np.sum(W**2)\n","    loss_reg_bu = 0.5 * lambda_bias_func * np.sum(user_bias**2); loss_reg_bi = 0.5 * lambda_bias_func * np.sum(movie_bias**2)\n","    total_loss = loss_obs + loss_reg_U + loss_reg_W + loss_reg_bu + loss_reg_bi\n","    E_sparse = sparse.csr_matrix((errors, (rows_idx_filt, cols_idx_filt)), shape=(n_movies_func, n_users_func))\n","    E_sparse_csc = E_sparse.tocsc()\n","    grad_U = E_sparse @ W.T + lambda_sq_func * U\n","    grad_W = U.T @ E_sparse_csc + lambda_sq_func * W\n","    grad_user_bias = np.array(E_sparse.sum(axis=0)).flatten() + lambda_bias_func * user_bias\n","    grad_movie_bias = np.array(E_sparse.sum(axis=1)).flatten() + lambda_bias_func * movie_bias\n","    if not np.isfinite(grad_U).all(): grad_U = np.nan_to_num(grad_U)\n","    if not np.isfinite(grad_W).all(): grad_W = np.nan_to_num(grad_W)\n","    if not np.isfinite(grad_user_bias).all(): grad_user_bias = np.nan_to_num(grad_user_bias)\n","    if not np.isfinite(grad_movie_bias).all(): grad_movie_bias = np.nan_to_num(grad_movie_bias)\n","    if not np.isfinite(total_loss): total_loss = np.inf\n","    return float(total_loss), grad_U.astype(np.float64), grad_W.astype(np.float64), grad_user_bias.astype(np.float64), grad_movie_bias.astype(np.float64)\n","\n","def gradient_batch_with_biases(\n","    U: np.ndarray, W: np.ndarray, user_bias: np.ndarray, movie_bias: np.ndarray,\n","    indices: np.ndarray, # Indices into GLOBAL triplets\n","    rows_idx: np.ndarray, cols_idx: np.ndarray, vals_true_centered: np.ndarray, # Centered ratings\n","    n_ratings_total: int,\n","    lambda_sq_func: float, lambda_bias_func: float\n",") -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n","    \"\"\" Computes average Euclidean gradient over a BATCH of ratings, including biases. \"\"\"\n","    U = U.astype(np.float64, copy=False)\n","    W = W.astype(np.float64, copy=False)\n","    user_bias = user_bias.astype(np.float64, copy=False)\n","    movie_bias = movie_bias.astype(np.float64, copy=False)\n","    batch_size = len(indices)\n","    if batch_size == 0:\n","        return np.zeros_like(U), np.zeros_like(W), np.zeros_like(user_bias), np.zeros_like(movie_bias)\n","\n","    # Get data for the batch\n","    batch_rows = rows_idx[indices]\n","    batch_cols = cols_idx[indices]\n","    batch_vals_centered = vals_true_centered[indices]\n","\n","    # Get corresponding factors and biases\n","    try:\n","        U_batch = U[batch_rows, :] # Shape (B, R)\n","        W_batch = W[:, batch_cols] # Shape (R, B)\n","        user_bias_batch = user_bias[batch_cols] # Shape (B,)\n","        movie_bias_batch = movie_bias[batch_rows] # Shape (B,)\n","    except IndexError as e:\n","         logger.error(f\"Indexing error in gradient_batch_with_biases - {e}\")\n","         raise\n","\n","    # Predict residual for the batch\n","    preds_batch_residual = user_bias_batch + movie_bias_batch + np.sum(U_batch * W_batch.T, axis=1)\n","\n","    # Calculate errors for the batch\n","    errors_batch = preds_batch_residual - batch_vals_centered # Shape (B,)\n","\n","    # Calculate gradient terms using sparse matrix approach\n","    E_sparse_batch = sparse.csr_matrix((errors_batch, (batch_rows, batch_cols)),\n","                                       shape=(U.shape[0], W.shape[1]))\n","\n","    # Average gradient over the batch\n","    grad_U_batch = (E_sparse_batch @ W.T) / batch_size + lambda_sq_func * U\n","    grad_W_batch = (U.T @ E_sparse_batch.tocsc()) / batch_size + lambda_sq_func * W\n","\n","    # Compute bias gradients (need to average errors per user/movie in batch)\n","    # This requires accumulating errors per user/movie index present in the batch\n","    grad_user_bias_batch = np.zeros_like(user_bias)\n","    grad_movie_bias_batch = np.zeros_like(movie_bias)\n","    np.add.at(grad_user_bias_batch, batch_cols, errors_batch) # Accumulate errors by user index\n","    np.add.at(grad_movie_bias_batch, batch_rows, errors_batch) # Accumulate errors by movie index\n","\n","    grad_user_bias_batch = grad_user_bias_batch / batch_size + lambda_bias_func * user_bias\n","    grad_movie_bias_batch = grad_movie_bias_batch / batch_size + lambda_bias_func * movie_bias\n","\n","    # Handle potential non-finite values\n","    if not np.isfinite(grad_U_batch).all(): grad_U_batch = np.nan_to_num(grad_U_batch)\n","    if not np.isfinite(grad_W_batch).all(): grad_W_batch = np.nan_to_num(grad_W_batch)\n","    if not np.isfinite(grad_user_bias_batch).all(): grad_user_bias_batch = np.nan_to_num(grad_user_bias_batch)\n","    if not np.isfinite(grad_movie_bias_batch).all(): grad_movie_bias_batch = np.nan_to_num(grad_movie_bias_batch)\n","\n","    return grad_U_batch.astype(np.float64), grad_W_batch.astype(np.float64), grad_user_bias_batch.astype(np.float64), grad_movie_bias_batch.astype(np.float64)\n","\n","# --- SVRG Solver ---\n","# --- SVRG Solver with Biases ---\n","def run_non_convex_svrg_with_biases(\n","    R_train_coo: sparse.coo_matrix, # Contains centered ratings\n","    global_mean: float,\n","    probe_users_mapped: np.ndarray, # Mapped probe indices\n","    probe_movies_mapped: np.ndarray,\n","    probe_ratings_true: np.ndarray, # Original probe ratings\n","    N_users_active: int,\n","    M_movies_active: int,\n","    rank_local: int,\n","    n_epochs: int,\n","    inner_lr: float, # Base inner learning rate\n","    batch_size: int,\n","    lam_sq: float,\n","    lam_bias: float,\n","    rng: Generator,\n","    init_scale: float = INIT_SCALE_NON_CONVEX,\n","    max_grad_norm: float = GRAD_CLIP_THRESHOLD\n",") -> Dict[str, List]:\n","    \"\"\"\n","    Runs SVRG for non-convex UW factorization including bias terms.\n","    Uses decaying LR and gradient clipping.\n","    \"\"\"\n","    logger.info(\"Starting Non-Convex SVRG Solver with Biases...\")\n","    # Initialize factors and biases\n","    U, W, user_bias, movie_bias = initialize_factors_and_biases(\n","        M_movies_active, N_users_active, rank_local, rng, init_scale\n","    )\n","\n","    hist_loss = []\n","    hist_rmse = []\n","    hist_time = []\n","    hist_gU_norm, hist_gW_norm, hist_gBu_norm, hist_gBi_norm = [], [], [], []\n","\n","    start_time = time.time()\n","\n","    # Use mapped indices and centered ratings for training\n","    train_rows = R_train_coo.row\n","    train_cols = R_train_coo.col\n","    train_vals_centered = R_train_coo.data\n","    n_ratings_total = R_train_coo.nnz\n","\n","    if n_ratings_total == 0:\n","        logger.error(\"No training ratings available.\")\n","        return {'loss': [], 'rmse': [], 'time': [], 'gU_norm': [], 'gW_norm': [], 'gBu_norm': [], 'gBi_norm': [], 'U': None, 'W': None, 'bu': None, 'bi': None}\n","\n","    # Initial evaluation\n","    try:\n","        loss0, gU0, gW0, gBu0, gBi0 = loss_and_grad_serial_with_biases(\n","            U, W, user_bias, movie_bias, global_mean,\n","            train_rows, train_cols, train_vals_centered,\n","            M_movies_active, N_users_active, rank_local, lam_sq, lam_bias\n","        )\n","        rmse0 = evaluate_rmse_with_biases(\n","            U, W, user_bias, movie_bias, global_mean,\n","            probe_users_mapped, probe_movies_mapped, probe_ratings_true\n","        )\n","        hist_loss.append(loss0)\n","        hist_rmse.append(rmse0)\n","        hist_time.append(time.time() - start_time)\n","        hist_gU_norm.append(np.linalg.norm(gU0))\n","        hist_gW_norm.append(np.linalg.norm(gW0))\n","        hist_gBu_norm.append(np.linalg.norm(gBu0))\n","        hist_gBi_norm.append(np.linalg.norm(gBi0))\n","        logger.info(\n","            f\"Epoch 00 (Init): Loss={loss0:.4e}, RMSE={rmse0:.4f}, \"\n","            f\"||gU||={hist_gU_norm[-1]:.2e}, ||gW||={hist_gW_norm[-1]:.2e}, \"\n","            f\"||gBu||={hist_gBu_norm[-1]:.2e}, ||gBi||={hist_gBi_norm[-1]:.2e}\"\n","        )\n","    except Exception as e:\n","        logger.error(f\"Error during initial evaluation: {e}\", exc_info=True)\n","        return {'loss': [], 'rmse': [], 'time': [], 'gU_norm': [], 'gW_norm': [], 'gBu_norm': [], 'gBi_norm': [], 'U': None, 'W': None, 'bu': None, 'bi': None}\n","\n","    # Main SVRG Loop\n","    for epoch in range(1, n_epochs + 1):\n","        epoch_start_time = time.time()\n","        logger.info(f\"--- Starting Epoch {epoch:02d} ---\")\n","        # --- Use Exponential Decay for Learning Rate (FIX 4) ---\n","        lr_epoch = inner_lr * (0.9**(epoch - 1)) # Exponential decay\n","        logger.info(f\"Using lr = {lr_epoch:.2e} this epoch\")\n","        # ---------------------------------------------\n","\n","        # Compute anchor gradient\n","        logger.info(f\"Epoch {epoch:02d}: Computing anchor gradient...\")\n","        anchor_start_time = time.time()\n","        try:\n","            loss_anchor, gU_anchor, gW_anchor, gBu_anchor, gBi_anchor = loss_and_grad_serial_with_biases(\n","                U, W, user_bias, movie_bias, global_mean,\n","                train_rows, train_cols, train_vals_centered,\n","                M_movies_active, N_users_active, rank_local, lam_sq, lam_bias\n","            )\n","            logger.info(f\"Epoch {epoch:02d}: Anchor gradient computed in {time.time() - anchor_start_time:.2f}s.\")\n","        except Exception as e:\n","            logger.error(f\"Error computing anchor gradient at epoch {epoch}: {e}\")\n","            break\n","\n","        U_epoch_start, W_epoch_start = U.copy(), W.copy()\n","        user_bias_epoch_start, movie_bias_epoch_start = user_bias.copy(), movie_bias.copy()\n","\n","        # Inner loop\n","        # --- Use Full Inner Pass (FIX 5) ---\n","        num_inner_steps = max(1, (n_ratings_total // batch_size) // SVRG_INNER_STEPS_DIVISOR)\n","        logger.info(f\"Epoch {epoch:02d}: Starting inner loop with {num_inner_steps} steps...\")\n","        inner_loop_start_time = time.time()\n","\n","        for inner_step in range(num_inner_steps):\n","            batch_indices = rng.choice(n_ratings_total, size=batch_size, replace=False)\n","            try:\n","                gU_curr, gW_curr, gBu_curr, gBi_curr = gradient_batch_with_biases(\n","                    U, W, user_bias, movie_bias, batch_indices,\n","                    train_rows, train_cols, train_vals_centered,\n","                    n_ratings_total, lam_sq, lam_bias)\n","                gU_anch, gW_anch, gBu_anch, gBi_anch = gradient_batch_with_biases(\n","                    U_epoch_start, W_epoch_start, user_bias_epoch_start, movie_bias_epoch_start,\n","                    batch_indices, train_rows, train_cols, train_vals_centered,\n","                    n_ratings_total, lam_sq, lam_bias)\n","            except Exception as e:\n","                logger.error(f\"Error computing stochastic gradient: {e}\")\n","                continue\n","\n","            # Variance-reduced gradients\n","            gU_vr = gU_curr - gU_anch + gU_anchor\n","            gW_vr = gW_curr - gW_anch + gW_anchor\n","            gBu_vr = gBu_curr - gBu_anch + gBu_anchor\n","            gBi_vr = gBi_curr - gBi_anch + gBi_anchor\n","\n","            # Gradient clipping\n","            gU_norm = np.linalg.norm(gU_vr); gW_norm = np.linalg.norm(gW_vr)\n","            gBu_norm = np.linalg.norm(gBu_vr); gBi_norm = np.linalg.norm(gBi_vr)\n","            if gU_norm > max_grad_norm: gU_vr *= (max_grad_norm / gU_norm)\n","            if gW_norm > max_grad_norm: gW_vr *= (max_grad_norm / gW_norm)\n","            if gBu_norm > max_grad_norm: gBu_vr *= (max_grad_norm / gBu_norm)\n","            if gBi_norm > max_grad_norm: gBi_vr *= (max_grad_norm / gBi_norm)\n","\n","            # Update factors and biases\n","            U -= lr_epoch * gU_vr\n","            W -= lr_epoch * gW_vr\n","            user_bias -= lr_epoch * gBu_vr\n","            movie_bias -= lr_epoch * gBi_vr\n","\n","            if (inner_step + 1) % 5000 == 0: # Log less frequently for full inner pass\n","                logger.info(f\"Epoch {epoch:02d}: Inner step {inner_step+1}/{num_inner_steps} done.\")\n","\n","        logger.info(f\"Epoch {epoch:02d}: Inner loop finished in {time.time() - inner_loop_start_time:.2f}s.\")\n","\n","        # Evaluate after epoch\n","        logger.info(f\"Epoch {epoch:02d}: Evaluating loss and RMSE...\")\n","        eval_start_time = time.time()\n","        try:\n","            loss_k, gU_k, gW_k, gBu_k, gBi_k = loss_and_grad_serial_with_biases(\n","                U, W, user_bias, movie_bias, global_mean,\n","                train_rows, train_cols, train_vals_centered,\n","                M_movies_active, N_users_active, rank_local, lam_sq, lam_bias\n","            )\n","            if not np.isfinite(loss_k):\n","                logger.error(f\"Epoch {epoch:02d}: Loss became non-finite ({loss_k}). Stopping.\")\n","                hist_loss.append(np.nan); hist_rmse.append(np.nan); hist_time.append(time.time() - start_time)\n","                hist_gU_norm.append(np.nan); hist_gW_norm.append(np.nan); hist_gBu_norm.append(np.nan); hist_gBi_norm.append(np.nan)\n","                break\n","\n","            rmse_k = evaluate_rmse_with_biases(\n","                U, W, user_bias, movie_bias, global_mean,\n","                probe_users_mapped, probe_movies_mapped, probe_ratings_true\n","            )\n","            hist_loss.append(loss_k); hist_rmse.append(rmse_k)\n","            hist_time.append(time.time() - start_time)\n","            hist_gU_norm.append(np.linalg.norm(gU_k)); hist_gW_norm.append(np.linalg.norm(gW_k))\n","            hist_gBu_norm.append(np.linalg.norm(gBu_k)); hist_gBi_norm.append(np.linalg.norm(gBi_k))\n","\n","            logger.info(f\"Epoch {epoch:02d}: Eval done in {time.time() - eval_start_time:.2f}s. \")\n","            logger.info(\n","                f\"Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, \"\n","                f\"||gU||={hist_gU_norm[-1]:.2e}, ||gW||={hist_gW_norm[-1]:.2e}, \"\n","                f\"||gBu||={hist_gBu_norm[-1]:.2e}, ||gBi||={hist_gBi_norm[-1]:.2e}\"\n","            )\n","        except Exception as e:\n","            logger.error(f\"Error during evaluation at epoch {epoch}: {e}\", exc_info=True)\n","            hist_loss.append(np.nan); hist_rmse.append(np.nan); hist_time.append(time.time() - start_time)\n","            hist_gU_norm.append(np.nan); hist_gW_norm.append(np.nan); hist_gBu_norm.append(np.nan); hist_gBi_norm.append(np.nan)\n","            break\n","\n","        logger.info(f\"--- Epoch {epoch:02d} finished in {time.time() - epoch_start_time:.2f}s ---\")\n","\n","    logger.info(\"Non-Convex SVRG Solver with Biases Finished.\")\n","    return {\n","        'loss': hist_loss, 'rmse': hist_rmse, 'time': hist_time,\n","        'gU_norm': hist_gU_norm, 'gW_norm': hist_gW_norm,\n","        'gBu_norm': hist_gBu_norm, 'gBi_norm': hist_gBi_norm,\n","        'U': U, 'W': W, 'bu': user_bias, 'bi': movie_bias\n","    }\n","\n","\n","# --- ALS Solver ---\n","\n","def W_closed_efficient(U, N_users, N_movies, user_indices=None):\n","    # Solves for W for a subset of users (local computation)\n","    U = U.astype(np.float32, copy=False);\n","    target_users = user_indices if user_indices is not None else user_data_arrays.keys()\n","    W_subset = {} # Use dict if only computing for subset\n","    I_r_lam_sq = (LAM_SQ * I_r).astype(np.float32) # lambda^2 * I\n","\n","    for u in target_users:\n","        if u not in user_data_arrays: continue\n","        data = user_data_arrays[u]\n","        movie_indices = data['movies']; rs_t = data['rs']\n","        if movie_indices.size == 0: continue\n","        # Check bounds before indexing U\n","        if movie_indices.max() >= U.shape[0] or movie_indices.min() < 0:\n","            # if RANK_MPI == 0: print(f\"Warning: Invalid movie indices for user {u}. Skipping.\")\n","            continue\n","        U_k = U[movie_indices, :]\n","        A = U_k.T @ U_k + I_r_lam_sq\n","        B = U_k.T @ rs_t\n","        A = A.astype(np.float32); B = B.astype(np.float32)\n","        try:\n","            w_u = np.linalg.solve(A.astype(np.float64), B.astype(np.float64)).astype(np.float32)\n","        except np.linalg.LinAlgError:\n","            # if RANK_MPI == 0: print(f\"Warning: np.linalg.solve failed for user {u}. Using pseudo-inverse.\")\n","            try:\n","                w_u = (np.linalg.pinv(A.astype(np.float64)) @ B.astype(np.float64)).astype(np.float32)\n","            except np.linalg.LinAlgError:\n","                if RANK_MPI == 0: print(f\"ERROR: Pseudo-inverse also failed for user {u}. Returning zero vector.\")\n","                w_u = np.zeros(RANK, dtype=np.float32) # Return zero vector if fails completely\n","            except Exception as e_pinv:\n","                 if RANK_MPI == 0: print(f\"ERROR: Unknown error in pseudo-inverse for user {u}: {e_pinv}. Returning zero vector.\")\n","                 w_u = np.zeros(RANK, dtype=np.float32)\n","\n","        if user_indices is not None:\n","            W_subset[u] = w_u\n","        else:\n","            if 'W' not in locals(): W = np.zeros((RANK, N_users), dtype=np.float32)\n","            if 0 <= u < W.shape[1]: # Check user index bound for W\n","                 W[:, u] = w_u\n","            # else: # This shouldn't happen if N_users is correct\n","            #    if RANK_MPI == 0: print(f\"Warning: User index {u} out of bounds for W (shape {W.shape}).\")\n","\n","\n","    if user_indices is not None:\n","        return W_subset # Return dict\n","    else:\n","        if 'W' not in locals():\n","            # if RANK_MPI == 0: print(\"Warning: W_closed_efficient called with no active users? Returning empty W.\")\n","            return np.zeros((RANK, N_users), dtype=np.float32)\n","        # W should be filled now\n","        if not np.isfinite(W).all():\n","            if RANK_MPI == 0: print(\"Warning: Non-finite values found in computed W matrix. Clamping.\")\n","            W = np.nan_to_num(W, nan=0.0, posinf=0.0, neginf=0.0) # Clamp non-finite to zero\n","        assert W.shape == (RANK, N_users);\n","        return W # Return full W matrix\n","\n","\n","def update_user_factors(\n","    R_train_coo_csc: sparse.csc_matrix, # Centered ratings, CSC format\n","    U: np.ndarray,\n","    user_bias: np.ndarray,\n","    movie_bias: np.ndarray,\n","    lambda_sq: float,\n","    rank: int,\n","    N_users: int\n",") -> np.ndarray:\n","    \"\"\"Solves for W (user factors) fixing U and biases.\"\"\"\n","    M = U.shape[0]\n","    W = np.zeros((rank, N_users), dtype=np.float64)\n","    # Precompute U^T U + lambda*I (used in the denominator)\n","    # Note: This is used inside the loop per user based on specific movies U_j\n","    # UtU = U.T @ U + lambda_sq * np.eye(rank, dtype=np.float64) # Can't precompute fully\n","\n","    for j in range(N_users):\n","        # Find ratings for user j\n","        start_idx = R_train_coo_csc.indptr[j]\n","        end_idx = R_train_coo_csc.indptr[j+1]\n","        if start_idx == end_idx: # No ratings for this user\n","            continue\n","\n","        movie_indices = R_train_coo_csc.indices[start_idx:end_idx]\n","        ratings_centered = R_train_coo_csc.data[start_idx:end_idx]\n","\n","        U_j = U[movie_indices, :] # Movies rated by user j (n_j x R)\n","\n","        # Adjust ratings by movie bias: r_ij - mu - b_i\n","        adjusted_ratings = ratings_centered - movie_bias[movie_indices]\n","\n","        # Calculate A = U_j^T U_j + lambda*I\n","        A = U_j.T @ U_j + lambda_sq * np.eye(rank, dtype=np.float64)\n","\n","        # Calculate b = U_j^T * adjusted_ratings\n","        b = U_j.T @ adjusted_ratings\n","\n","        try:\n","            W[:, j] = np.linalg.solve(A, b)\n","        except np.linalg.LinAlgError:\n","            logger.warning(f\"ALS: Solve failed for user {j}, using pseudo-inverse.\")\n","            try:\n","                W[:, j] = np.linalg.pinv(A) @ b\n","            except Exception as e_pinv:\n","                 logger.error(f\"ALS: Pseudo-inverse failed for user {j}: {e_pinv}. Setting W_j to zero.\")\n","                 W[:, j] = 0.0 # Set to zero vector\n","\n","    return W.astype(np.float64)\n","\n","def update_movie_factors(\n","    R_train_coo_csr: sparse.csr_matrix, # Centered ratings, CSR format\n","    W: np.ndarray,\n","    user_bias: np.ndarray,\n","    movie_bias: np.ndarray,\n","    lambda_sq: float,\n","    rank: int,\n","    M_movies: int\n",") -> np.ndarray:\n","    \"\"\"Solves for U (movie factors) fixing W and biases.\"\"\"\n","    N = W.shape[1]\n","    U = np.zeros((M_movies, rank), dtype=np.float64)\n","    # Precompute W W^T + lambda*I (used in the denominator)\n","    # Note: This is used inside the loop per movie based on specific users W_i\n","    # WtW = W @ W.T + lambda_sq * np.eye(rank, dtype=np.float64) # Can't precompute fully\n","\n","    for i in range(M_movies):\n","        # Find ratings for movie i\n","        start_idx = R_train_coo_csr.indptr[i]\n","        end_idx = R_train_coo_csr.indptr[i+1]\n","        if start_idx == end_idx: # No ratings for this movie\n","            continue\n","\n","        user_indices = R_train_coo_csr.indices[start_idx:end_idx]\n","        ratings_centered = R_train_coo_csr.data[start_idx:end_idx]\n","\n","        W_i = W[:, user_indices] # Users who rated movie i (R x n_i)\n","\n","        # Adjust ratings by user bias: r_ij - mu - b_u\n","        adjusted_ratings = ratings_centered - user_bias[user_indices]\n","\n","        # Calculate A = W_i W_i^T + lambda*I\n","        A = W_i @ W_i.T + lambda_sq * np.eye(rank, dtype=np.float64)\n","\n","        # Calculate b = W_i * adjusted_ratings\n","        b = W_i @ adjusted_ratings\n","\n","        try:\n","            U[i, :] = np.linalg.solve(A, b)\n","        except np.linalg.LinAlgError:\n","             logger.warning(f\"ALS: Solve failed for movie {i}, using pseudo-inverse.\")\n","             try:\n","                 U[i, :] = np.linalg.pinv(A) @ b\n","             except Exception as e_pinv:\n","                 logger.error(f\"ALS: Pseudo-inverse failed for movie {i}: {e_pinv}. Setting U_i to zero.\")\n","                 U[i, :] = 0.0 # Set to zero vector\n","\n","    return U.astype(np.float64)\n","\n","\n","def update_biases(\n","    R_train_coo: sparse.coo_matrix, # Centered ratings\n","    U: np.ndarray,\n","    W: np.ndarray,\n","    user_bias: np.ndarray,\n","    movie_bias: np.ndarray,\n","    global_mean: float,\n","    lambda_bias: float,\n","    N_users: int,\n","    M_movies: int\n",") -> Tuple[np.ndarray, np.ndarray]:\n","    \"\"\"Updates user and movie biases based on current residuals.\"\"\"\n","    new_user_bias = np.zeros_like(user_bias)\n","    new_movie_bias = np.zeros_like(movie_bias)\n","    user_counts = np.zeros_like(user_bias)\n","    movie_counts = np.zeros_like(movie_bias)\n","\n","    # Calculate residuals: r_ij - mu - U_i^T W_j\n","    rows, cols, vals_centered = R_train_coo.row, R_train_coo.col, R_train_coo.data\n","    dot_prods = np.array([np.dot(U[r, :], W[:, c]) for r, c in zip(rows, cols)], dtype=np.float64)\n","    residuals = vals_centered - dot_prods # Residual = (r_ij - mu) - U_i^T W_j\n","\n","    # Update user biases: b_u = sum(residual - b_i) / (count + lambda_bias)\n","    np.add.at(new_user_bias, cols, residuals - movie_bias[rows])\n","    np.add.at(user_counts, cols, 1)\n","    new_user_bias = new_user_bias / (user_counts + lambda_bias + 1e-9) # Add epsilon for stability\n","\n","    # Update movie biases: b_i = sum(residual - b_u) / (count + lambda_bias)\n","    np.add.at(new_movie_bias, rows, residuals - new_user_bias[cols]) # Use updated user bias\n","    np.add.at(movie_counts, rows, 1)\n","    new_movie_bias = new_movie_bias / (movie_counts + lambda_bias + 1e-9) # Add epsilon for stability\n","\n","    return new_user_bias.astype(np.float64), new_movie_bias.astype(np.float64)\n","\n","def run_als_with_biases(\n","    R_train_coo: sparse.coo_matrix, # Centered ratings\n","    global_mean: float,\n","    probe_users_mapped: np.ndarray,\n","    probe_movies_mapped: np.ndarray,\n","    probe_ratings_true: np.ndarray,\n","    N_users_active: int,\n","    M_movies_active: int,\n","    rank_local: int,\n","    n_iters: int, # Max iterations\n","    lam_sq: float,\n","    lam_bias: float,\n","    rng: Generator,\n","    init_scale: float = INIT_SCALE_NON_CONVEX,\n","    tol: float = ALS_TOL\n",") -> Dict[str, List]:\n","    \"\"\"Runs Alternating Least Squares with biases.\"\"\"\n","    logger.info(\"Starting ALS Solver with Biases...\")\n","    U, W, user_bias, movie_bias = initialize_factors_and_biases(\n","        M_movies_active, N_users_active, rank_local, rng, init_scale\n","    )\n","\n","    hist_loss = [] # Loss not typically tracked directly in ALS, focus on RMSE\n","    hist_rmse = []\n","    hist_time = []\n","\n","    start_time = time.time()\n","    last_rmse = np.inf\n","\n","    # Precompute sparse matrix formats for efficiency\n","    R_train_csc = R_train_coo.tocsc()\n","    R_train_csr = R_train_coo.tocsr()\n","\n","    for k_iter in range(1, n_iters + 1):\n","        iter_start_time = time.time()\n","        logger.info(f\"--- Starting ALS Iteration {k_iter:02d} ---\")\n","\n","        # Update user factors (W)\n","        logger.debug(f\"Iter {k_iter}: Updating user factors (W)...\")\n","        W = update_user_factors(R_train_csc, U, user_bias, movie_bias, lam_sq, rank_local, N_users_active)\n","\n","        # Update movie factors (U)\n","        logger.debug(f\"Iter {k_iter}: Updating movie factors (U)...\")\n","        U = update_movie_factors(R_train_csr, W, user_bias, movie_bias, lam_sq, rank_local, M_movies_active)\n","\n","        # Update biases\n","        logger.debug(f\"Iter {k_iter}: Updating biases...\")\n","        user_bias, movie_bias = update_biases(R_train_coo, U, W, user_bias, movie_bias, global_mean, lam_bias, N_users_active, M_movies_active)\n","\n","        # Evaluate RMSE\n","        logger.debug(f\"Iter {k_iter}: Evaluating RMSE...\")\n","        current_rmse = evaluate_rmse_with_biases(\n","            U, W, user_bias, movie_bias, global_mean,\n","            probe_users_mapped, probe_movies_mapped, probe_ratings_true\n","        )\n","        current_time = time.time() - start_time\n","        hist_rmse.append(current_rmse)\n","        hist_time.append(current_time)\n","\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k_iter:02d}: RMSE = {current_rmse:.6f} (Time: {iter_time:.2f}s)\")\n","\n","        # Check convergence\n","        if abs(last_rmse - current_rmse) < tol:\n","            logger.info(f\"ALS converged at iteration {k_iter} (RMSE change < {tol})\")\n","            break\n","        last_rmse = current_rmse\n","\n","    logger.info(\"ALS Solver with Biases Finished.\")\n","    return {\n","        'loss': [], # ALS doesn't typically track the combined loss easily\n","        'rmse': hist_rmse,\n","        'time': hist_time,\n","        'U': U, 'W': W, 'bu': user_bias, 'bi': movie_bias\n","    }\n","\n","# --- Stochastic Gradient Single User (NEW - for SARAH/SPIDER) ---\n","def stochastic_gradient_single_user(U, user_idx, N_users, N_movies, loss_args):\n","    \"\"\" Computes the UNSCALED gradient component d L_user_idx / dU for a single user. \"\"\"\n","    # Unpack loss_args (assumes structure matches loss_and_grad_serial_with_biases)\n","    global_mean, rows_idx, cols_idx, vals_true_centered, _, _, rank_func, lambda_sq_func, lambda_bias_func = loss_args\n","    M, R = U.shape\n","    G_user = np.zeros_like(U, dtype=np.float32)\n","    if user_idx not in user_data_arrays: return G_user # Use precomputed user_data_arrays\n","\n","    W_user_dict = W_closed_efficient(U, N_users, N_movies, user_indices=[user_idx]) # Recompute W for this user\n","    if user_idx not in W_user_dict: return G_user\n","\n","    w_u = W_user_dict[user_idx]\n","    user_data = user_data_arrays[user_idx]\n","    movie_indices = user_data['movies']; rs_t = user_data['rs'] # rs_t are original ratings here\n","    if movie_indices.size == 0: return G_user\n","    if movie_indices.max() >= M or movie_indices.min() < 0: return G_user # Return zero grad if invalid index\n","\n","    # Need centered ratings and biases for gradient calculation\n","    # Recompute biases? Or assume they are passed implicitly? Assume passed via loss_args implicitly (not ideal)\n","    # This function signature needs alignment with how biases are handled if used by SARAH/SPIDER\n","    # For now, approximate using centered ratings and current factors\n","    # This needs refinement if SARAH/SPIDER are primary focus\n","    ratings_centered_user = rs_t - global_mean # Approximate centering\n","\n","    U_k = U[movie_indices, :]\n","    # Need bias terms here for correct error calculation\n","    # Placeholder: Calculate error without biases for now\n","    preds_k_dot = U_k @ w_u\n","    err_k = preds_k_dot - ratings_centered_user # Error against centered rating\n","\n","    grad_vals_k = err_k # Simplified grad without prox term from loss_and_grad\n","    term_k = grad_vals_k.reshape(-1, 1) * w_u.reshape(1, -1)\n","    np.add.at(G_user, movie_indices, term_k.astype(np.float32))\n","    # Add regularization gradient for U rows involved\n","    G_user[movie_indices, :] += lambda_sq_func * U_k\n","\n","    if not np.isfinite(G_user).all():\n","        G_user = np.nan_to_num(G_user, nan=0.0, posinf=0.0, neginf=0.0)\n","    assert G_user.shape == U.shape\n","    return G_user\n","# --- Euclidean GD Solver (NEW from long.txt, adapted for biases) ---\n","def run_euclidean_gd(\n","    R_train_coo, global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true,\n","    N_users_active, M_movies_active, rank_local, n_iters,\n","    lam_sq, lam_bias, rng, init_scale=INIT_SCALE_NON_CONVEX, lr=1e-7 # Use specific LR\n",") -> Dict[str, List]:\n","    \"\"\"Runs Vanilla Euclidean GD with biases.\"\"\"\n","    if RANK_MPI == 0: logger.info(f\"\\n+++ Running Vanilla Euclidean GD (LR={lr:.1e}) +++\")\n","    U_euc, W_euc, user_bias, movie_bias = initialize_factors_and_biases(M_movies_active, N_users_active, rank_local, rng, init_scale)\n","    # Note: Euclidean GD doesn't require U to be orthonormal, so we use the direct output\n","\n","    hist_loss, hist_grad, hist_rmse, hist_time = [], [], [], []; t_start = time.time();\n","    loss_args_biased = (global_mean, R_train_coo.row, R_train_coo.col, R_train_coo.data, M_movies_active, N_users_active, rank_local, lam_sq, lam_bias)\n","    eval_args_biased = (global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true)\n","\n","    try:\n","        current_loss, current_rmse, gU_k, gW_k, gBu_k, gBi_k = record_initial_state_biased(U_euc, W_euc, user_bias, movie_bias, loss_args_biased, eval_args_biased)\n","        grad_norm_k = np.linalg.norm(gU_k) # Use Euclidean norm for U gradient\n","    except Exception as e:\n","        if RANK_MPI == 0: print(f\"  ERROR during initial state recording for Euclidean GD: {e}\")\n","        return {'loss': [], 'grad_norm': [], 'rmse': [], 'time': []}\n","\n","    if RANK_MPI == 0: hist_loss.append(current_loss); hist_grad.append(grad_norm_k); hist_rmse.append(current_rmse); hist_time.append(time.time() - t_start)\n","\n","    if RANK_MPI == 0: logger.info(\"\\n  Starting Euclidean GD iterations...\")\n","    for k in range(n_iters):\n","        iter_t0 = time.time();\n","        # --- inside your Euclidean-GD loop ---\n","        if grad_norm_k < 1e-6:\n","            if RANK_MPI == 0:\n","                logger.info(f\"EucGD converged at iter {k}\")   # or print(...)\n","            break\n","\n","\n","        # Simple Euclidean gradient step for all variables\n","        U_euc -= lr * gU_k\n","        W_euc -= lr * gW_k\n","        user_bias -= lr * gBu_k\n","        movie_bias -= lr * gBi_k\n","\n","        if not (np.isfinite(U_euc).all() and np.isfinite(W_euc).all()):\n","            if RANK_MPI == 0: print(f\"EucGD Warning: Non-finite factors at iter {k+1}\"); break\n","\n","        try:\n","            current_loss, gU_k, gW_k, gBu_k, gBi_k = loss_and_grad_serial_with_biases(U_euc, W_euc, user_bias, movie_bias, *loss_args_biased)\n","            current_rmse = evaluate_rmse_with_biases(U_euc, W_euc, user_bias, movie_bias, *eval_args_biased)\n","            grad_norm_k = np.linalg.norm(gU_k) # Euclidean norm\n","            if not (np.isfinite(current_loss) and np.isfinite(gU_k).all() and (np.isnan(current_rmse) or np.isfinite(current_rmse))):\n","                if RANK_MPI == 0: print(f\"EucGD Warning: Non-finite values encountered iter {k+1}.\")\n","                break\n","        except Exception as e:\n","            if RANK_MPI == 0: print(f\"EucGD Error during iteration {k+1}: {e}\")\n","            break\n","\n","        if RANK_MPI == 0:\n","            hist_loss.append(current_loss); hist_grad.append(grad_norm_k); hist_rmse.append(current_rmse); hist_time.append(time.time() - t_start)\n","            if k % 5 == 0 or k == n_iters - 1: print(f\"  EucGD Iter {k+1:02d} | Loss: {current_loss:.3e} | GradNorm: {grad_norm_k:.3e} | RMSE: {current_rmse:.4f} | Time: {time.time()-iter_t0:.2f}s\")\n","\n","    if RANK_MPI == 0: logger.info(f\"EucGD finished in {time.time()-t_start:.2f}s\");\n","    return {'loss': hist_loss, 'grad_norm': hist_grad, 'rmse': hist_rmse, 'time': hist_time, 'U': U_euc, 'W': W_euc, 'bu': user_bias, 'bi': movie_bias}\n"],"metadata":{"id":"5UKS8C7DMTDt","executionInfo":{"status":"ok","timestamp":1746544967728,"user_tz":240,"elapsed":50,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}}},"execution_count":9,"outputs":[]},{"cell_type":"code","source":["all_results = {} #added on 5/6\n","\n","# ============================================================================ #\n","# CELL 5: Riemannian Solvers (RGD, RAGD, Catalyst, DANE) - Renumbered\n","# ============================================================================ #\n","logger.info(\"+++ Cell 5: Defining Riemannian Solvers +++\")\n","# --- Stochastic Solvers (SARAH, SPIDER) ---\n","\n","def run_soft_impute_efficient(\n","    R_train_coo_orig: sparse.coo_matrix, # Original ratings, mapped indices\n","    probe_users_mapped: np.ndarray,\n","    probe_movies_mapped: np.ndarray,\n","    probe_ratings_true: np.ndarray, # Original probe ratings\n","    N_users_active: int,\n","    M_movies_active: int,\n","    n_iters: int,\n","    lambda_reg: float,\n","    k_rank: int, # Initial rank guess / cap for SVD\n","    tol: float,\n","    rng: Generator\n",") -> Dict[str, List]:\n","    \"\"\" Solves convex problem using efficient Soft-Impute with LinearOperator SVD. \"\"\"\n","    logger.info(\"Starting Efficient Convex Soft-Impute Solver (CPU)...\")\n","    use_gpu = False # Force CPU as LinearOperator uses SciPy\n","\n","    # Prepare necessary sparse formats of original ratings\n","    R_orig_csr = R_train_coo_orig.tocsr()\n","    R_orig_csc = R_train_coo_orig.tocsc()\n","    # Create Omega mask (1s where ratings exist)\n","    omega_mask_csr = R_orig_csr.copy(); omega_mask_csr.data[:] = 1\n","    omega_mask_csc = omega_mask_csr.tocsc()\n","\n","    # Initialize factors U, S, V\n","    initial_k = max(1, min(k_rank, M_movies_active, N_users_active))\n","    U = rng.standard_normal(size=(M_movies_active, initial_k)).astype(np.float64) * 0.01\n","    S = np.zeros(initial_k, dtype=np.float64) # Start with S=0 -> Xk=0 initially\n","    V = rng.standard_normal(size=(N_users_active, initial_k)).astype(np.float64) * 0.01\n","    if N_users_active >= initial_k: V, _ = np.linalg.qr(V, mode='reduced') # Orthonormalize V initially\n","\n","    U_old, S_old, V_old = U.copy(), S.copy(), V.copy()\n","    hist_loss, hist_rmse, hist_time, hist_rank = [], [], [], []\n","    start_time = time.time()\n","    current_svd_k = initial_k # Rank for svds call\n","\n","    for k_iter in range(1, n_iters + 1):\n","        iter_start_time = time.time()\n","        logger.info(f\"--- Starting SoftImpute Iteration {k_iter:02d} ---\")\n","\n","        # Define Linear Operator for Z = P_Omega(R_orig) + P_Omega_Complement(USV^T)\n","        Z_op = ImplicitFillOperator(R_orig_csr, R_orig_csc, omega_mask_csr, omega_mask_csc, U, S, V, (M_movies_active, N_users_active))\n","\n","        # Perform SVD using the LinearOperator\n","        logger.debug(f\"Iter {k_iter}: Performing SVD with k={current_svd_k}...\")\n","        svd_start_time = time.time()\n","        try:\n","            # Ensure k for svds is valid\n","            k_svds = max(1, min(current_svd_k, M_movies_active - 1, N_users_active - 1))\n","            if k_svds <= 0:\n","                 logger.warning(f\"Iter {k_iter}: Matrix dimensions too small for SVD. Skipping.\")\n","                 rank_k = 0; S_new = np.array([], dtype=np.float64)\n","                 U_new = np.zeros((M_movies_active, 0), dtype=np.float64)\n","                 Vt_new = np.zeros((0, N_users_active), dtype=np.float64) # Need Vt shape\n","            else:\n","                # Use scipy's svds which works with LinearOperator\n","                U_new, S_new_raw, Vt_new = svds(Z_op, k=k_svds, which='LM', tol=1e-4, maxiter=100) # Adjust svds tol/maxiter if needed\n","\n","            # svds returns sorted singular values (largest first) - reverse order\n","            S_new_raw = S_new_raw[::-1]\n","            U_new = U_new[:, ::-1]\n","            Vt_new = Vt_new[::-1, :]\n","\n","            S_new = soft_threshold(S_new_raw, lambda_reg) # Threshold\n","            V_new = Vt_new.T # Transpose Vt to get V\n","            rank_k = int(np.sum(S_new > 1e-10))\n","\n","            logger.debug(f\"Iter {k_iter}: SVD finished in {time.time() - svd_start_time:.2f}s. Rank after thresholding: {rank_k}\")\n","\n","            if rank_k == 0:\n","                 logger.warning(f\"Iter {k_iter}: Rank became zero. Resetting.\")\n","                 current_svd_k = 1 # Reset k for next SVD\n","                 U = np.zeros((M_movies_active, 1), dtype=np.float64)\n","                 S = np.zeros(1, dtype=np.float64)\n","                 V = np.zeros((N_users_active, 1), dtype=np.float64)\n","            else:\n","                 U = U_new[:, :rank_k].copy()\n","                 S = S_new[:rank_k].copy()\n","                 V = V_new[:, :rank_k].copy()\n","                 current_svd_k = min(rank_k + 5, CONVEX_RANK_K) # Increase k slightly for next iter, capped\n","\n","        except Exception as e:\n","            logger.error(f\"SVD failed during SoftImpute iter {k_iter}: {e}\", exc_info=True)\n","            break\n","\n","        # Convergence Check\n","        U_diff_norm = np.linalg.norm(U - U_old, 'fro'); S_diff_norm = np.linalg.norm(S - S_old, 'fro'); V_diff_norm = np.linalg.norm(V - V_old, 'fro')\n","        U_norm = max(1.0, np.linalg.norm(U_old, 'fro')); S_norm = max(1.0, np.linalg.norm(S_old, 'fro')); V_norm = max(1.0, np.linalg.norm(V_old, 'fro'))\n","        relative_diff = max(U_diff_norm / U_norm, S_diff_norm / S_norm, V_diff_norm / V_norm) if U_norm > 0 and S_norm > 0 and V_norm > 0 else np.inf\n","        logger.debug(f\"Iter {k_iter}: Max Rel Factor Diff={relative_diff:.4e}, Rank={rank_k}\")\n","\n","        # Evaluate Metrics\n","        eval_start_time = time.time()\n","        try:\n","            # Objective: 0.5 * ||P_Omega(X - R_orig)||_F^2 + lambda * ||X||_*\n","            rows, cols = R_train_coo_orig.row, R_train_coo_orig.col\n","            vals_orig = R_train_coo_orig.data\n","            preds_at_omega_k = np.array([np.dot(U[r, :], S * V[c, :]) for r, c in zip(rows, cols)], dtype=np.float64)\n","            loss_obs_k = 0.5 * np.sum((preds_at_omega_k - vals_orig)**2)\n","            nuclear_norm_k = np.sum(S)\n","            loss_k = loss_obs_k + lambda_reg * nuclear_norm_k\n","\n","            # RMSE: Predict original scale ratings (USV^T) and compare to true validation ratings\n","            dot_prods_probe = np.array([np.dot(U[m, :], S * V[u, :]) for m, u in zip(probe_movies_mapped, probe_users_mapped)], dtype=np.float64)\n","            preds_probe_clamped = np.clip(dot_prods_probe, 1.0, 5.0) # Clamp prediction\n","            valid_true_mask_probe = ~np.isnan(ratings_val_true)\n","            if np.any(valid_true_mask_probe):\n","                 mse_probe = np.mean((preds_probe_clamped[valid_true_mask_probe] - ratings_val_true[valid_true_mask_probe])**2)\n","                 rmse_k = np.sqrt(mse_probe) if mse_probe >= 0 else np.nan\n","            else: rmse_k = np.nan\n","\n","        except Exception as e: logger.error(f\"Error during SoftImpute evaluation: {e}\"); loss_k, rmse_k, rank_k = np.nan, np.nan, rank_k if 'rank_k' in locals() else -1\n","\n","        eval_time = time.time() - eval_start_time\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time); hist_rank.append(rank_k)\n","        U_old, S_old, V_old = U.copy(), S.copy(), V.copy() # Update for next convergence check\n","\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k_iter:02d}: Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, Rank={rank_k}, Rel Diff={relative_diff:.4e} (Eval: {eval_time:.2f}s, Total: {iter_time:.2f}s)\")\n","\n","        if relative_diff < tol: logger.info(f\"Soft-Impute converged at iteration {k_iter}\"); break\n","\n","    logger.info(\"Efficient Convex Soft-Impute Solver Finished.\")\n","    return {'loss': hist_loss, 'rmse': hist_rmse, 'time': hist_time, 'rank': hist_rank, 'U': U, 'S': S, 'V': V}\n","\n","\n","# --- Stochastic Solvers (SARAH, SPIDER) ---\n","class RiemannianSARAH: # Adapted from long.txt\n","    def __init__(self, R, P, g_i, g_batch, batch_size=100, m=1000, eta=1e-3, rng=None):\n","        self.R, self.P, self.g_i, self.g_batch = R, P, g_i, g_batch\n","        self.B, self.m, self.eta = batch_size, m, eta\n","        self.rng = default_rng(rng) if rng is None else rng\n","    def run(self, U0, n_steps, grad_args, active_idx, sampling_prob=None):\n","        if active_idx is None or len(active_idx) == 0: return U0\n","        rng = self.rng; U = U0.copy().astype(np.float32); v = np.zeros_like(U0, dtype=np.float32)\n","        U_prev = U.copy().astype(np.float32); num_active = len(active_idx)\n","        for t in range(n_steps):\n","            if t % self.m == 0:\n","                current_batch_size = min(self.B, num_active);\n","                if current_batch_size == 0: continue\n","                batch_indices = rng.choice(active_idx, size=current_batch_size, p=sampling_prob, replace=True)\n","                try: v = self.g_batch(U, batch_indices, *grad_args).astype(np.float32)\n","                except Exception as e: logger.error(f\"SARAH refresh grad error: {e}\"); v = np.zeros_like(U)\n","                if not np.isfinite(v).all(): logger.warning(f\"SARAH non-finite refresh grad step {t}\"); v = np.zeros_like(U)\n","            else:\n","                if num_active == 0: continue\n","                i_idx = rng.choice(active_idx, size=1, p=sampling_prob, replace=True)[0]; i = int(i_idx)\n","                try:\n","                    v_new = self.g_i(U, i, *grad_args).astype(np.float32)\n","                    v_old = self.g_i(U_prev, i, *grad_args).astype(np.float32)\n","                    if np.isfinite(v_new).all() and np.isfinite(v_old).all(): v += v_new - v_old\n","                except Exception as e: logger.error(f\"SARAH single grad error user {i}: {e}\")\n","            G_proj = self.P(U, v); step = (-self.eta * G_proj).astype(np.float32)\n","            if should_stop_subproblem(G_proj, step): break\n","            U_prev = U.copy(); U_next = self.R(U, step)\n","            if not np.isfinite(U_next).all(): logger.warning(f\"SARAH non-finite U step {t+1}\"); U = U_prev; break\n","            U = U_next\n","        return U\n","class RiemannianSPIDER: # Adapted from long.txt\n","    def __init__(self, retraction, proj, grad_i, grad_batch, m=100, step=1e-3, rng=None):\n","        self.R = retraction; self.P = proj; self.g_i = grad_i; self.g_batch = grad_batch\n","        self.m = m; self.eta = step\n","        self.rng = default_rng(rng) if rng is None else rng\n","    def run(self, U0, n_steps, grad_args, active_idx, sampling_prob=None):\n","        if active_idx is None or len(active_idx) == 0: return U0\n","        rng = self.rng; U = U0.copy().astype(np.float32); v = np.zeros_like(U0, dtype=np.float32)\n","        U_prev = U0.copy().astype(np.float32); num_active = len(active_idx)\n","        for t in range(n_steps):\n","            if t % self.m == 0:\n","                current_batch_size = min(self.m, num_active); # Use m as batch size for refresh\n","                if current_batch_size == 0: continue\n","                batch_indices = rng.choice(active_idx, size=current_batch_size, p=sampling_prob, replace=True)\n","                try: v = self.g_batch(U, batch_indices, *grad_args).astype(np.float32)\n","                except Exception as e: logger.error(f\"SPIDER refresh grad error: {e}\"); v = np.zeros_like(U)\n","                if not np.isfinite(v).all(): logger.warning(f\"SPIDER non-finite refresh grad step {t}\"); v = np.zeros_like(U)\n","            else:\n","                if num_active == 0: continue\n","                i_idx = rng.choice(active_idx, size=1, p=sampling_prob, replace=True)[0]; i = int(i_idx)\n","                try:\n","                    grad_new = self.g_i(U, i, *grad_args).astype(np.float32)\n","                    grad_old = self.g_i(U_prev, i, *grad_args).astype(np.float32)\n","                    if np.isfinite(grad_new).all() and np.isfinite(grad_old).all(): v = v + grad_new - grad_old\n","                except Exception as e: logger.error(f\"SPIDER single grad error user {i}: {e}\")\n","            G_proj = self.P(U, v); step_vec = (-self.eta * G_proj).astype(np.float32)\n","            if should_stop_subproblem(G_proj, step_vec): break\n","            U_prev = U.copy(); U_next = self.R(U, step_vec)\n","            if not np.isfinite(U_next).all(): logger.warning(f\"SPIDER non-finite U step {t+1}\"); U = U_prev; break\n","            U = U_next\n","        return U\n","# --- RGD Solver ---\n","\n","def run_rgd_with_biases(\n","    R_train_coo, global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true,\n","    N_users_active, M_movies_active, rank_local, n_iters,\n","    lam_sq, lam_bias, rng, init_scale=INIT_SCALE_NON_CONVEX,\n","    lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA\n",") -> Dict[str, List]:\n","    \"\"\"Runs Riemannian Gradient Descent with biases.\"\"\"\n","    logger.info(\"Starting RGD Solver with Biases...\")\n","    U, W, user_bias, movie_bias = initialize_factors_and_biases(M_movies_active, N_users_active, rank_local, rng, init_scale)\n","    hist_loss, hist_rmse, hist_time, hist_grad_norm = [], [], [], []\n","    start_time = time.time(); lr_k = lr_init\n","    loss_args_biased = (global_mean, R_train_coo.row, R_train_coo.col, R_train_coo.data, M_movies_active, N_users_active, rank_local, lam_sq, lam_bias)\n","    eval_args_biased = (global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true)\n","    try:\n","        loss_k, rmse_k, gU_k, gW_k, gBu_k, gBi_k = record_initial_state_biased(U, W, user_bias, movie_bias, loss_args_biased, eval_args_biased)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        gU_proj_k = ProjTangent(U, gU_k); hist_grad_norm.append(np.linalg.norm(gU_proj_k))\n","    except Exception as e: logger.error(f\"RGD Init Error: {e}\"); return {'loss': [], 'rmse': [], 'time': [], 'grad_norm': []}\n","\n","    for k in range(n_iters):\n","        iter_start_time = time.time()\n","        gU_proj_k = ProjTangent(U, gU_k)\n","        grad_norm_k = np.linalg.norm(gU_proj_k)\n","        hist_grad_norm.append(grad_norm_k)\n","\n","        # --- FIX: Check Riemannian Gradient Norm ---\n","        if grad_norm_k < 1e-6: logger.info(\"RGD Converged (grad norm)\"); break\n","        # -------------------------------------------\n","\n","        ls_loss_args = (W, user_bias, movie_bias) + loss_args_biased\n","        lr_step, U_next, loss_next = ArmijoLineSearchRiemannian(U, gU_k, ls_loss_args, loss_k, lr_k, ls_beta, ls_sigma)\n","        if lr_step == 0.0: logger.warning(\"RGD Line search failed.\"); break\n","\n","        lr_fixed_other = 1e-4\n","        W -= lr_fixed_other * gW_k; user_bias -= lr_fixed_other * gBu_k; movie_bias -= lr_fixed_other * gBi_k\n","        U = U_next; loss_k = loss_next\n","        lr_k = min(lr_step / np.sqrt(ls_beta), lr_init * 2)\n","\n","        _, gU_k, gW_k, gBu_k, gBi_k = loss_and_grad_serial_with_biases(U, W, user_bias, movie_bias, *loss_args_biased)\n","        rmse_k = evaluate_rmse_with_biases(U, W, user_bias, movie_bias, *eval_args_biased)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k+1:02d}: Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, GradNorm={grad_norm_k:.2e}, LR={lr_step:.2e} (Time: {iter_time:.2f}s)\")\n","\n","    logger.info(\"RGD Solver Finished.\")\n","\n","# --- RAGD Solver ---\n","\n","#\n","# --- RAGD Solver ---\n","def run_ragd_with_biases(\n","    R_train_coo, global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true,\n","    N_users_active, M_movies_active, rank_local, n_iters,\n","    lam_sq, lam_bias, rng, init_scale=INIT_SCALE_NON_CONVEX,\n","    lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA,\n","    gamma=RAGD_GAMMA, mu=RAGD_MU, beta_ragd=RAGD_BETA\n",") -> Dict[str, List]:\n","    \"\"\"Runs Riemannian Accelerated Gradient Descent with biases.\"\"\"\n","    logger.info(\"Starting RAGD Solver with Biases...\")\n","    U_k, W_k, user_bias_k, movie_bias_k = initialize_factors_and_biases(M_movies_active, N_users_active, rank_local, rng, init_scale)\n","    nu_k = U_k.copy() # Momentum state\n","    gamma_k = gamma\n","    min_lambda_k = lr_init\n","\n","    hist_loss, hist_rmse, hist_time, hist_grad_norm = [], [], [], []\n","    start_time = time.time()\n","\n","    loss_args_biased = (global_mean, R_train_coo.row, R_train_coo.col, R_train_coo.data, M_movies_active, N_users_active, rank_local, lam_sq, lam_bias)\n","    eval_args_biased = (global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true)\n","\n","    try:\n","        loss_k, rmse_k, gU_k, gW_k, gBu_k, gBi_k = record_initial_state_biased(U_k, W_k, user_bias_k, movie_bias_k, loss_args_biased, eval_args_biased)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        gU_proj_k = ProjTangent(U_k, gU_k); hist_grad_norm.append(np.linalg.norm(gU_proj_k))\n","    except Exception as e: logger.error(f\"RAGD Init Error: {e}\"); return {'loss': [], 'rmse': [], 'time': [], 'grad_norm': []}\n","\n","    def solve_alpha_eqn(current_min_lambda, gamma, mu):\n","        a = 1.0; b = current_min_lambda * (gamma - mu); c = -current_min_lambda * gamma\n","        delta = b**2 - 4*a*c\n","        if delta < 0: return 0.0\n","        alpha1 = (-b + np.sqrt(delta))/(2*a); alpha2 = (-b - np.sqrt(delta))/(2*a)\n","        if 0 < alpha1 < 1: return alpha1\n","        if 0 < alpha2 < 1: return alpha2\n","        return 0.0\n","\n","    for k in range(n_iters):\n","        iter_start_time = time.time()\n","        logger.info(f\"--- Starting RAGD Iteration {k+1:02d} ---\")\n","\n","        alpha = solve_alpha_eqn(min_lambda_k, gamma_k, mu)\n","        if alpha == 0.0: alpha = 1e-6 # Avoid division by zero / stagnation\n","        gamma_bar = (1 - alpha) * gamma_k + alpha * mu\n","        if gamma_bar == 0.0: gamma_bar = 1e-6\n","\n","        # Extrapolation step for y_t (only on U)\n","        logmap_nu_theta = LogMapApprox(U_k, nu_k)\n","        y_t = OrthRetraction(U_k, (alpha * gamma_k / gamma_bar) * logmap_nu_theta)\n","\n","        # Gradient at y_t (need W and biases at y_t? Assume they stay at k for simplicity)\n","        loss_yt, gU_yt, gW_yt, gBu_yt, gBi_yt = loss_and_grad_serial_with_biases(\n","            y_t, W_k, user_bias_k, movie_bias_k, *loss_args_biased\n","        )\n","\n","        # Line search from y_t to find theta_{k+1} (U_{k+1})\n","        ls_loss_args = (W_k, user_bias_k, movie_bias_k) + loss_args_biased\n","        lr_step, U_kp1, loss_kp1 = ArmijoLineSearchRiemannian(\n","            y_t, gU_yt, ls_loss_args, loss_yt, min_lambda_k, ls_beta, ls_sigma\n","        )\n","\n","        if lr_step == 0.0: logger.warning(\"RAGD Line search failed.\"); break\n","        min_lambda_k = lr_step # Update min LR found\n","\n","        # Update nu (momentum state)\n","        logmap_nu_yt = LogMapApprox(y_t, nu_k)\n","        grad_proj_yt = ProjTangent(y_t, gU_yt)\n","        nu_update_vec = ((1 - alpha) * gamma_k / gamma_bar) * logmap_nu_yt - (alpha / gamma_bar) * grad_proj_yt\n","        nu_kp1 = OrthRetraction(y_t, nu_update_vec)\n","\n","        # Update W and biases (simple gradient step with decayed LR for stability)\n","        lr_fixed_other = 1e-4 * (0.9**k) # Use a small decaying LR\n","        W_kp1 = W_k - lr_fixed_other * gW_k\n","        user_bias_kp1 = user_bias_k - lr_fixed_other * gBu_k\n","        movie_bias_kp1 = movie_bias_k - lr_fixed_other * gBi_k\n","\n","        # Update state\n","        U_k, W_k, user_bias_k, movie_bias_k = U_kp1, W_kp1, user_bias_kp1, movie_bias_kp1\n","        nu_k = nu_kp1\n","        gamma_k = gamma_bar / (1 + beta_ragd) # Update gamma\n","        loss_k = loss_kp1\n","\n","        # Evaluate and record\n","        rmse_k = evaluate_rmse_with_biases(U_k, W_k, user_bias_k, movie_bias_k, *eval_args_biased)\n","        # Recompute gradient at the final point U_k for norm calculation\n","        _, gU_k_final, gW_k, gBu_k, gBi_k = loss_and_grad_serial_with_biases(U_k, W_k, user_bias_k, movie_bias_k, *loss_args_biased)\n","        gU_proj_k = ProjTangent(U_k, gU_k_final)\n","        grad_norm_k = np.linalg.norm(gU_proj_k)\n","\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        hist_grad_norm.append(grad_norm_k)\n","\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k+1:02d}: Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, GradNorm={grad_norm_k:.2e}, LR={lr_step:.2e} (Time: {iter_time:.2f}s)\")\n","\n","        if grad_norm_k < 1e-6: logger.info(\"RAGD Converged (grad norm)\"); break\n","\n","    logger.info(\"RAGD Solver Finished.\")\n","    return {'loss': hist_loss, 'rmse': hist_rmse, 'time': hist_time, 'grad_norm': hist_grad_norm, 'U': U_k, 'W': W_k, 'bu': user_bias_k, 'bi': movie_bias_k}\n","\n","# --- Catalyst Solver ---\n","# --- Catalyst Solver (Modified for Stochastic Inner Solvers) ---\n","def run_catalyst_stochastic( # Renamed from run_catalyst_phi2_with_biases\n","    R_train_coo, global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true,\n","    N_users_active, M_movies_active, rank_local, n_iters,\n","    lam_sq, lam_bias, rng, init_scale=INIT_SCALE_NON_CONVEX,\n","    lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA,\n","    kappa_0=KAPPA_0, kappa_cvx=KAPPA_CVX, inner_T_epochs=CATALYST_INNER_T_EPOCHS,\n","    inner_S_epochs_base=CATALYST_INNER_S_EPOCHS_BASE,\n","    max_kappa_doublings=MAX_KAPPA_DOUBLINGS,\n","    inner_solver_type=INNER_SOLVER, # NEW: Specify inner solver\n","    inner_solver_lr = RSVRG_LR, # NEW: LR for stochastic inner solver\n","    inner_solver_bs = RSVRG_BATCH_SIZE # NEW: Batch size for stochastic inner solver\n",") -> Dict[str, List]:\n","    \"\"\"Runs Catalyst-Phi2 using a specified stochastic Riemannian solver.\"\"\"\n","    solver_name = inner_solver_type.upper()\n","    logger.info(f\"Starting Catalyst-Phi2 + {solver_name} Solver with Biases...\")\n","    theta_k, W_k, user_bias_k, movie_bias_k = initialize_factors_and_biases(M_movies_active, N_users_active, rank_local, rng, init_scale)\n","    theta_km1 = theta_k.copy(); tilde_theta_km1 = theta_k.copy()\n","    alpha_k = 1.0; kappa_k = kappa_0\n","    hist_loss, hist_rmse, hist_time, hist_grad_norm = [], [], [], []\n","    phi1_grad_hist, phi1_dist_hist = [], [] # Rank 0 diagnostics\n","    start_time = time.time()\n","    loss_args_biased = (global_mean, R_train_coo.row, R_train_coo.col, R_train_coo.data, M_movies_active, N_users_active, rank_local, lam_sq, lam_bias)\n","    eval_args_biased = (global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true)\n","    grad_args_stoch = (N_users_active, M_movies_active, loss_args_biased) # Args for stochastic grad funcs\n","    n_data = R_train_coo.nnz # Use number of ratings for epoch length calculation? Or users? Use users.\n","    n_active_users = N_users_active\n","    epoch_len_batches = max(1, n_active_users // inner_solver_bs) if n_active_users > 0 else 1\n","    theta_tilde_k = None #added here on 5/5/2025\n","    try:\n","        loss_k, rmse_k, gU_k, gW_k, gBu_k, gBi_k = record_initial_state_biased(theta_k, W_k, user_bias_k, movie_bias_k, loss_args_biased, eval_args_biased)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        gU_proj_k = ProjTangent(theta_k, gU_k); hist_grad_norm.append(np.linalg.norm(gU_proj_k))\n","    except Exception as e: logger.error(f\"Catalyst-{solver_name} Init Error: {e}\"); return {'loss': [], 'rmse': [], 'time': [], 'grad_norm': []}\n","\n","    # Instantiate selected inner solver (consistent across ranks)\n","    inner_solver_instance = None\n","    refresh_period_m = max(1, epoch_len_batches // 2) # Example refresh period\n","    solver_args_inner = {\n","        'R': R_fn, 'P': ProjTangent, 'eta': inner_solver_lr,\n","        'g_i': stochastic_gradient_single_user, 'g_batch': stochastic_gradient_batch,\n","        #'g_batch': stochastic_gradient_batch,     # now resolved 5/4/2025\n","        'rng': default_rng(SEED + 1 + RANK_MPI) # Ensure different RNG streams per rank\n","    }\n","    if inner_solver_type == \"sarah\": InnerSolverClass = RiemannianSARAH; solver_args_inner.update({'batch_size': inner_solver_bs, 'm': refresh_period_m})\n","    elif inner_solver_type == \"spider\": InnerSolverClass = RiemannianSPIDER; solver_args_inner.update({'m': refresh_period_m})\n","    elif inner_solver_type == \"svrg\": InnerSolverClass = None # SVRG logic remains embedded\n","    else: raise ValueError(f\"Unknown INNER_SOLVER: {inner_solver_type}\")\n","    if InnerSolverClass: inner_solver_instance = InnerSolverClass(**solver_args_inner)\n","\n","\n","    theta_tilde_k : Optional[np.ndarray] = None   # <-- avoids UnboundLocalError #added on 5/5/2025\n","    for k in range(1, n_iters + 1):\n","        iter_start_time = time.time()\n","        logger.info(f\"--- Starting Catalyst-{solver_name} Iteration {k:02d} ---\")\n","        kappa_step1 = kappa_k; doubling_count = 0\n","        inner_T_steps_budget = epoch_len_batches * inner_T_epochs # Steps budget\n","\n","        logger.debug(f\"Iter {k}: Running Phi1 (kappa adaptation)...\")\n","        while True:\n","            prox_center = theta_km1.copy()\n","            # --- Run Inner Solver for Step 1 ---\n","            U_inner1 = None\n","            if InnerSolverClass:\n","                 try:\n","                      logger.warning(f\"Running inner {solver_name} on f, not h_kappa in Phi1.\")\n","                      solver_args_run = (grad_args_stoch, unique_users_train, sampling_prob) # Pass active user IDs\n","                      U_inner1 = inner_solver_instance.run(prox_center, inner_T_steps_budget, *solver_args_run)\n","                 except Exception as e_inner: logger.error(f\"Inner {solver_name} (Step 1) failed: {e_inner}\"); U_inner1 = prox_center\n","            else: # Embedded SVRG for Step 1 subproblem\n","                U_snapshot = prox_center.copy()\n","                G_full_snapshot = np.zeros_like(U_snapshot) # Calculate full gradient estimate\n","                if n_active_users > 0:\n","                    num_batches_for_full_grad = max(1, math.ceil(n_active_users / inner_solver_bs / 5))\n","                    count_full = 0\n","                    for _ in range(num_batches_for_full_grad):\n","                        current_batch_size = min(inner_solver_bs, n_active_users)\n","                        if current_batch_size == 0: continue\n","                        batch_ids_full = GLOBAL_RNG.choice(unique_users_train, size=current_batch_size, p=sampling_prob, replace=True)\n","                        try: G_batch = stochastic_gradient_batch(U_snapshot, batch_ids_full, *grad_args_stoch);\n","                        except Exception: continue\n","                        if np.isfinite(G_batch).all(): G_full_snapshot += G_batch; count_full += 1\n","                    if count_full > 0: G_full_snapshot /= count_full\n","                U_inner1_svrg = U_snapshot.copy();\n","                for i_t in range(inner_T_steps_budget):\n","                    current_batch_size = min(inner_solver_bs, n_active_users)\n","                    if current_batch_size == 0: break\n","                    batch_ids = GLOBAL_RNG.choice(unique_users_train, size=current_batch_size, p=sampling_prob, replace=True)\n","                    try: g_curr = stochastic_gradient_batch(U_inner1_svrg, batch_ids, *grad_args_stoch); g_ref  = stochastic_gradient_batch(U_snapshot, batch_ids, *grad_args_stoch)\n","                    except Exception: g_curr = np.zeros_like(U_inner1_svrg); g_ref = np.zeros_like(U_inner1_svrg)\n","                    if not (np.isfinite(g_curr).all() and np.isfinite(g_ref).all()): continue\n","                    G_vr_f = g_curr - g_ref + G_full_snapshot\n","                    if REG_DISTANCE == \"euclid\": G_prox_term = kappa_step1 * (U_inner1_svrg - prox_center);\n","                    else: G_prox_term = - kappa_step1 * LogMapApprox(U_inner1_svrg, prox_center)\n","                    subprob_G_vr_euclidean = G_vr_f + G_prox_term\n","                    G_proj_vr = ProjTangent(U_inner1_svrg, subprob_G_vr_euclidean)\n","                    step_vec = (-inner_solver_lr * G_proj_vr).astype(np.float32)\n","                    if should_stop_subproblem(G_proj_vr, step_vec): break\n","                    U_next_svrg = R_fn(U_inner1_svrg, step_vec)\n","                    if not np.isfinite(U_next_svrg).all(): break\n","                    U_inner1_svrg = U_next_svrg\n","                U_inner1 = U_inner1_svrg\n","\n","            # --- Check conditions after inner solve ---\n","            theta_bar_k_T = U_inner1;\n","            try: loss_bar_k_T, G_bar_k_T = loss_and_grad_corrected(theta_bar_k_T, W_k, user_bias_k, movie_bias_k, *loss_args_biased)\n","            except Exception as e: logger.error(f\"Error evaluating bar_theta: {e}\"); loss_bar_k_T = np.inf\n","            if not np.isfinite(loss_bar_k_T): kappa_step1 *= 2; doubling_count += 1; continue\n","            conditions_met = False; phi1_grad_norm = np.nan; d_R_approx = np.nan\n","            if RANK_MPI == 0: # Only rank 0 checks conditions\n","                d_R_approx = np.linalg.norm(LogMapApprox(theta_km1, theta_bar_k_T));\n","                h_k_bar = loss_bar_k_T + 0.5 * kappa_step1 * d_R_approx**2;\n","                loss_km1 = hist_loss[-1] if hist_loss else np.inf\n","                descent_cond_met = (h_k_bar <= loss_km1 + 1e-9 * (1 + abs(loss_km1)))\n","                if REG_DISTANCE == \"euclid\": subprob_grad_bar_k = G_bar_k_T + kappa_step1 * (theta_bar_k_T - theta_km1);\n","                else: subprob_grad_bar_k = G_bar_k_T - kappa_step1 * LogMapApprox(theta_bar_k_T, theta_km1)\n","                proj_grad_h = ProjTangent(theta_bar_k_T, subprob_grad_bar_k)\n","                phi1_grad_norm = np.linalg.norm(proj_grad_h)\n","                stationarity_rhs = kappa_step1 * d_R_approx\n","                stat_cond_met = phi1_grad_norm <= stationarity_rhs + 1e-9 * (1 + stationarity_rhs)\n","                if descent_cond_met and stat_cond_met:\n","                    print(f\"      Alg phi_1 Conditions MET kappa={kappa_step1:.1e}\")\n","                    phi1_grad_hist.append(phi1_grad_norm); phi1_dist_hist.append(d_R_approx)\n","                    kappa_k_next = update_kappa_adaptive(kappa_step1, phi1_grad_hist, phi1_dist_hist, theta_bar_k_T)\n","                    if abs(kappa_k_next - kappa_step1) > 1e-9: print(f\"      Adapting kappa next iter: {kappa_step1:.1e} -> {kappa_k_next:.1e}\")\n","                    kappa_k = kappa_k_next\n","                    conditions_met = True\n","                else: print(f\"      Alg phi_1 Conditions NOT MET (Desc:{descent_cond_met}, Stat:{stat_cond_met}) kappa={kappa_step1:.1e}. Doubling.\")\n","            if COMM and SIZE_MPI > 1: conditions_met = COMM.bcast(conditions_met, root=0); kappa_k = COMM.bcast(kappa_k, root=0) if conditions_met else kappa_k\n","            if conditions_met: break\n","            else:\n","                kappa_step1 *= 2; doubling_count += 1;\n","                if doubling_count >= MAX_KAPPA_DOUBLINGS: logger.warning(\"Phi1 max kappa doublings reached.\"); break\n","        if doubling_count >= MAX_KAPPA_DOUBLINGS: logger.error(f\"Catalyst Iter {k}: Phi1 failed. Stopping.\"); break\n","        bar_theta_k = theta_bar_k_T; loss_bar_k = loss_bar_k_T; G_bar_k = G_bar_k_T; kappa_k = kappa_step1\n","        logger.debug(f\"Iter {k}: Phi1 finished. Final kappa={kappa_k:.2e}\")\n","\n","        # === Step 2: Extrapolation ===\n","        if k == 1: V_extrap_approx = np.zeros_like(theta_km1)\n","        else: V_extrap_approx = LogMapApprox(theta_km1, tilde_theta_km1)\n","        vartheta_k = R_fn(theta_km1, alpha_k * V_extrap_approx);\n","        if not np.isfinite(vartheta_k).all(): logger.error(f\"Step 2 non-finite iter {k}. Stopping.\"); break\n","\n","        # === Step 3: Accelerated Step (using chosen solver) ===\n","        logger.debug(f\"Iter {k}: Running Phi2 (accelerated step)...\")\n","        prox_center_S = vartheta_k.copy()\n","        S_k_epochs = math.ceil(inner_S_epochs_base * math.log(k + 1))\n","        max_inner_iter_2 = S_k_epochs * epoch_len_batches\n","\n","        #theta_tilde_k = None\n","        if InnerSolverClass:\n","             try:\n","                  logger.warning(f\"Running inner {solver_name} on f, not h_kappa_cvx in Phi2.\")\n","                  solver_args_run_S = (grad_args_stoch, unique_users_train, sampling_prob)\n","                  theta_tilde_k = inner_solver_instance.run(prox_center_S, max_inner_iter_2, *solver_args_run_S)\n","             except Exception as e_inner_S: logger.error(f\"Inner {solver_name} (Step 3) failed: {e_inner_S}\"); theta_tilde_k = prox_center_S\n","        else: # Embedded SVRG for Step 3 subproblem\n","            U_snapshot_S = prox_center_S\n","            G_full_snapshot_S = np.zeros_like(U_snapshot_S) # Calculate full gradient estimate\n","            if n_active_users > 0:\n","                 num_batches_for_full_grad_S = max(1, math.ceil(n_active_users / inner_solver_bs / 5))\n","                 count_S_full = 0\n","                 for _ in range(num_batches_for_full_grad_S):\n","                      current_batch_size_S = min(inner_solver_bs, n_active_users)\n","                      if current_batch_size_S == 0: continue\n","                      batch_ids_full_S = GLOBAL_RNG.choice(unique_users_train, size=current_batch_size_S, p=sampling_prob, replace=True)\n","                      try: G_batch_S = stochastic_gradient_batch(U_snapshot_S, batch_ids_full_S, *grad_args_stoch);\n","                      except Exception: continue\n","                      if np.isfinite(G_batch_S).all(): G_full_snapshot_S += G_batch_S; count_S_full += 1\n","                 if count_S_full > 0: G_full_snapshot_S /= count_S_full\n","            U_inner2_svrg = U_snapshot_S.copy();\n","            for i_s in range(max_inner_iter_2):\n","                 current_batch_size_S = min(inner_solver_bs, n_active_users)\n","                 if current_batch_size_S == 0: break\n","                 batch_ids_S = GLOBAL_RNG.choice(unique_users_train, size=current_batch_size_S, p=sampling_prob, replace=True)\n","                 try: g_curr_S = stochastic_gradient_batch(U_inner2_svrg, batch_ids_S, *grad_args_stoch); g_ref_S  = stochastic_gradient_batch(U_snapshot_S, batch_ids_S, *grad_args_stoch)\n","                 except Exception: g_curr_S = np.zeros_like(U_inner2_svrg); g_ref_S = np.zeros_like(U_inner2_svrg)\n","                 if not (np.isfinite(g_curr_S).all() and np.isfinite(g_ref_S).all()): continue\n","                 G_vr_f_S = g_curr_S - g_ref_S + G_full_snapshot_S\n","                 if REG_DISTANCE == \"euclid\": G_prox_term_S = KAPPA_CVX * (U_inner2_svrg - prox_center_S);\n","                 else: G_prox_term_S = - KAPPA_CVX * LogMapApprox(U_inner2_svrg, prox_center_S)\n","                 subprob_G_vr_euclidean_S = G_vr_f_S + G_prox_term_S\n","                 G_proj_vr_S = ProjTangent(U_inner2_svrg, subprob_G_vr_euclidean_S)\n","                 step_vec_S = (-inner_solver_lr * G_proj_vr_S).astype(np.float32)\n","                 if should_stop_subproblem(G_proj_vr_S, step_vec_S): break\n","                 U_next_S = R_fn(U_inner2_svrg, step_vec_S)\n","                 if not np.isfinite(U_next_S).all(): break\n","                 U_inner2_svrg = U_next_S\n","            theta_tilde_k = U_inner2_svrg\n","        try: loss_tilde_k, G_tilde_k = loss_and_grad_corrected(\n","            theta_tilde_k,\n","            W_k,\n","            user_bias_k,\n","            movie_bias_k,\n","            *loss_args_biased\n","        )\n","#\n","        #try: loss_tilde_k, G_tilde_k = loss_and_grad_corrected(theta_tilde_k, *loss_args);\n","        except Exception as e: logger.error(f\"Error evaluating tilde_theta: {e}\"); loss_tilde_k = np.inf\n","        if not (np.isfinite(loss_tilde_k) and np.isfinite(G_tilde_k).all()): logger.error(f\"Step 3 ({solver_name}) failed iter {k}. Stopping.\"); break\n","\n","        # === Step 4, 5, 6 (Consistent) ===\n","        if loss_bar_k <= loss_tilde_k: theta_kp1, loss_kp1, G_kp1, selected = theta_bar_k, loss_bar_k, G_bar_k, \"bar\"\n","        else: theta_kp1, loss_kp1, G_kp1, selected = theta_tilde_k, loss_tilde_k, G_tilde_k, \"tilde\"\n","        V_update_approx = LogMapApprox(theta_km1, theta_tilde_k);\n","        tilde_theta_k_next = R_fn(theta_km1, (1.0 / alpha_k) * V_update_approx);\n","        if not np.isfinite(tilde_theta_k_next).all(): logger.error(f\"Step 5 non-finite iter {k}. Stopping.\"); break\n","        alpha_kp1 = (math.sqrt(alpha_k**4 + 4 * alpha_k**2) - alpha_k**2) / 2.0\n","\n","        # --- Update state for next iteration ---\n","        theta_km1 = theta_kp1.copy(); tilde_theta_km1 = tilde_theta_k_next.copy()\n","        alpha_k = alpha_kp1; loss_k = loss_kp1\n","        lr_fixed_other = 1e-4 * (0.9**k)\n","        _, _, gW_kp1, gBu_kp1, gBi_kp1 = loss_and_grad_serial_with_biases(theta_kp1, W_k, user_bias_k, movie_bias_k, *loss_args_biased)\n","        W_k -= lr_fixed_other * gW_kp1; user_bias_k -= lr_fixed_other * gBu_kp1; movie_bias_k -= lr_fixed_other * gBi_kp1\n","\n","        # --- Record History ---\n","        rmse_k = evaluate_rmse_with_biases(theta_kp1, W_k, user_bias_k, movie_bias_k, *eval_args_biased)\n","        gU_proj_k = ProjTangent(theta_kp1, G_kp1); grad_norm_k = np.linalg.norm(gU_proj_k)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time); hist_grad_norm.append(grad_norm_k)\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k:02d}: Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, GradNorm={grad_norm_k:.2e}, Kappa={kappa_k:.2e} (Time: {iter_time:.2f}s)\")\n","        if grad_norm_k < 1e-6: logger.info(f\"Catalyst-{solver_name} Converged (grad norm)\"); break\n","\n","    logger.info(f\"Catalyst-{solver_name} Solver Finished.\")\n","    if k == n_iters: # Append final grad norm if loop finished normally\n","         _, gU_k_final, _, _, _ = loss_and_grad_serial_with_biases(theta_k, W_k, user_bias_k, movie_bias_k, *loss_args_biased)\n","         gU_proj_k = ProjTangent(theta_k, gU_k_final); hist_grad_norm.append(np.linalg.norm(gU_proj_k))\n","    return {'loss': hist_loss, 'rmse': hist_rmse, 'time': hist_time, 'grad_norm': hist_grad_norm, 'U': theta_k, 'W': W_k, 'bu': user_bias_k, 'bi': movie_bias_k}\n","\n","\n","# --- DANE Solver ---\n","\n","# --- DANE Solver ---\n","def run_dane_with_biases(\n","    R_train_coo, global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true,\n","    N_users_active, M_movies_active, rank_local, n_iters,\n","    lam_sq, lam_bias, rng, init_scale=INIT_SCALE_NON_CONVEX,\n","    lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA,\n","    kappa=DANE_KAPPA\n",") -> Dict[str, List]:\n","    \"\"\"Runs DANE adaptation with biases.\"\"\"\n","    logger.info(\"Starting DANE Solver with Biases...\")\n","    theta_k, W_k, user_bias_k, movie_bias_k = initialize_factors_and_biases(M_movies_active, N_users_active, rank_local, rng, init_scale)\n","    theta_km1 = theta_k.copy()\n","\n","    hist_loss, hist_rmse, hist_time, hist_grad_norm = [], [], [], []\n","    start_time = time.time()\n","    lr_k = lr_init\n","\n","    loss_args_biased = (global_mean, R_train_coo.row, R_train_coo.col, R_train_coo.data, M_movies_active, N_users_active, rank_local, lam_sq, lam_bias)\n","    eval_args_biased = (global_mean, probe_users_mapped, probe_movies_mapped, probe_ratings_true)\n","\n","    try:\n","        loss_k, rmse_k, gU_k, gW_k, gBu_k, gBi_k = record_initial_state_biased(theta_k, W_k, user_bias_k, movie_bias_k, loss_args_biased, eval_args_biased)\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","        gU_proj_k = ProjTangent(theta_k, gU_k); hist_grad_norm.append(np.linalg.norm(gU_proj_k))\n","    except Exception as e: logger.error(f\"DANE Init Error: {e}\"); return {'loss': [], 'rmse': [], 'time': [], 'grad_norm': []}\n","\n","    for k in range(n_iters):\n","        iter_start_time = time.time()\n","        logger.info(f\"--- Starting DANE Iteration {k+1:02d} ---\")\n","\n","        if k == 0:\n","            grad_combined = gU_k # Use initial gradient for first step\n","        else:\n","            reg_grad = RegularizeGradChordalApprox(theta_k, theta_km1, kappa)\n","            grad_combined = gU_k + reg_grad # gU_k is from end of previous iteration\n","\n","        gU_proj_k = ProjTangent(theta_k, grad_combined)\n","        grad_norm_k = np.linalg.norm(gU_proj_k)\n","        hist_grad_norm.append(grad_norm_k) # Log norm before step\n","\n","        if grad_norm_k < 1e-6: logger.info(\"DANE Converged (grad norm)\"); break\n","\n","        # Line search on U update using combined gradient\n","        ls_loss_args = (W_k, user_bias_k, movie_bias_k) + loss_args_biased\n","        lr_step, U_kp1, loss_kp1 = ArmijoLineSearchRiemannian(\n","            theta_k, grad_combined, ls_loss_args, loss_k, lr_k, ls_beta, ls_sigma\n","        )\n","\n","        if lr_step == 0.0: logger.warning(\"DANE Line search failed.\"); break\n","\n","        # Update W and biases (simple gradient step with decayed LR?)\n","        lr_fixed_other = 1e-4 * (0.9**k)\n","        W_kp1 = W_k - lr_fixed_other * gW_k\n","        user_bias_kp1 = user_bias_k - lr_fixed_other * gBu_k\n","        movie_bias_kp1 = movie_bias_k - lr_fixed_other * gBi_k\n","\n","        # Update state\n","        theta_km1 = theta_k.copy() # Store previous U\n","        theta_k = U_kp1\n","        W_k, user_bias_k, movie_bias_k = W_kp1, user_bias_kp1, movie_bias_kp1\n","        loss_k = loss_kp1\n","        lr_k = min(lr_step / np.sqrt(ls_beta), lr_init * 2) # Update LR for next search\n","\n","        # Recompute gradients at new point for next iteration\n","        _, gU_k, gW_k, gBu_k, gBi_k = loss_and_grad_serial_with_biases(theta_k, W_k, user_bias_k, movie_bias_k, *loss_args_biased)\n","        rmse_k = evaluate_rmse_with_biases(theta_k, W_k, user_bias_k, movie_bias_k, *eval_args_biased)\n","\n","        hist_loss.append(loss_k); hist_rmse.append(rmse_k); hist_time.append(time.time() - start_time)\n","\n","        iter_time = time.time() - iter_start_time\n","        logger.info(f\"Iter {k+1:02d}: Loss={loss_k:.4e}, RMSE={rmse_k:.4f}, GradNorm={grad_norm_k:.2e}, LR={lr_step:.2e} (Time: {iter_time:.2f}s)\")\n","\n","    logger.info(\"DANE Solver Finished.\")\n","    return {'loss': hist_loss, 'rmse': hist_rmse, 'time': hist_time, 'grad_norm': hist_grad_norm, 'U': theta_k, 'W': W_k, 'bu': user_bias_k, 'bi': movie_bias_k}\n","# Create R_mask_coo (local partition mask, COO format)\n","# Using local_user_ids and local_movie_ids\n","'''if local_user_ids.size > 0:\n","    R_mask_coo = sparse.coo_matrix(\n","        (np.ones_like(local_user_ids, dtype=np.uint8), (local_movie_ids, local_user_ids)), # Value doesn't matter for mask, use 1s\n","        shape=(M_movies, N_users), # Use global dimensions for shape\n","        dtype=np.uint8 # Use uint8 for mask\n","    )\n","else:\n","    # Create an empty mask with the correct shape if no local data\n","    R_mask_coo = sparse.coo_matrix((M_movies, N_users), dtype=np.uint8)'''\n","def PROJ_TANGENT(U: np.ndarray, G: np.ndarray) -> np.ndarray:\n","    \"\"\"\n","    Project G onto the tangent space at U (Grassmann).\n","    \"\"\"\n","    return (G - U @ (U.T @ G)).astype(np.float32)\n","\n","def RECORDINITIALSTATE(U0: np.ndarray, W0: np.ndarray, L0: float, gU0: np.ndarray, gW0: np.ndarray) -> Dict[str, Any]:\n","    \"\"\"\n","    Records the initial state (U0, W0, loss0, gradient norms) for tracking.\n","\n","    Args:\n","        U0 (np.ndarray): Initial U matrix.\n","        W0 (np.ndarray): Initial W matrix (global).\n","        L0 (float): Initial loss.\n","        gU0 (np.ndarray): Initial gradient w.r.t. U (global).\n","        gW0 (np.ndarray): Initial gradient w.r.t. W (global).\n","\n","    Returns:\n","        dict: A dictionary containing the initial state information.\n","    \"\"\"\n","    d = dict(\n","        U0=U0.copy(), # Store copies\n","        W0=W0.copy(),\n","        loss0=float(L0),\n","        gU0_norm=float(np.linalg.norm(gU0)),\n","        gW0_norm=float(np.linalg.norm(gW0)),\n","        timestamp=time.time(), # Record time\n","    )\n","    if RANK_MPI == 0:\n","        logger.info(\"--- Initial state ---\", extra={\"rank\": RANK_MPI})\n","        logger.info(\"L0 = %.6e |‖∇U‖F=%.3e |‖∇W‖F=%.3e\",\n","                    d['loss0'], d['gU0_norm'], d['gW0_norm'], extra={\"rank\": RANK_MPI})\n","\n","    return d\n","def LOSSANDGRAD_TOTAL_DERIVATIVE(\n","    U: np.ndarray,\n","    X_local: sparse.csc_matrix,  # local sparse ratings (M x N) (CSC/CSR/COO)\n","    mask_coo_global: sparse.coo_matrix,  # Global mask matrix (M x N, uint8) indicating observed entries (COO)\n","    N_users: int,  # Total number of users globally\n","    M_movies: int,  # Total number of movies globally\n","    *,\n","    user_data_override: Optional[Dict[int, Dict[str, np.ndarray]]] = None,  # Optional override for user_data_arrays\n","    return_W: bool = False,  # If True, also returns the local W*(U) matrix\n",") -> Union[Tuple[float, np.ndarray], Tuple[float, np.ndarray, np.ndarray, np.ndarray]]:\n","    \"\"\"\n","    Computes the total profiled loss L(U, W*(U)) and its Euclidean total derivative dL/dU.\n","    Solves for W*(U) using a closed-form expression.\n","    Optionally returns the local W*(U) and local gradient with respect to W.\n","\n","    Args:\n","        U (np.ndarray): Current movie factor matrix (M x RANK, float64), assumed consistent across ranks.\n","        X_local (sparse matrix): The local partition of the training data matrix (M x N, float64).\n","        mask_coo_global (sparse.coo_matrix): The GLOBAL mask matrix (M x N, uint8) in COO format, indicating observed entries.\n","        N_users (int): Total number of users globally.\n","        M_movies (int): Total number of movies globally.\n","        user_data_override (dict, optional): Override for user_data_arrays when calling WCLOSEDEFFICIENT.\n","        return_W (bool): If True, returns W_local and local_gW0 as well.\n","\n","    Returns:\n","        If return_W=False:\n","            (total_loss, dL_dU)\n","        If return_W=True:\n","            (total_loss, dL_dU, local_grad_W, W_local)\n","        where:\n","            total_loss is a float64 scalar,\n","            dL_dU is an (M x RANK) float64 array,\n","            local_grad_W is an (RANK x N) float64 array,\n","            W_local is an (RANK x N) float64 array.\n","    \"\"\"\n","    U = U.astype(np.float64, copy=False)\n","    M, r = U.shape\n","\n","    # 1) Solve W*(U) for the local columns only.\n","    # WCLOSEDEFFICIENT returns the local part of W*(U), shape (r x N_users).\n","    W_local = WCLOSEDEFFICIENT(\n","        U=U,\n","        N_users=N_users,\n","        user_data_override=user_data_override\n","    )  # (r x N_users), float64\n","\n","    # 2) Observed-data term for the local slice\n","    local_obs_loss = 0.0\n","    local_grad_obs_term_U = np.zeros_like(U, dtype=np.float64)\n","    local_grad_obs_term_W = np.zeros_like(W_local, dtype=np.float64)\n","\n","    # Process only if there are non-zero entries in the local data AND the global mask\n","    if X_local.nnz and mask_coo_global.nnz:\n","        # Ensure mask is in COO format\n","        if not sparse.isspmatrix_coo(mask_coo_global):\n","            mask_coo_global = mask_coo_global.tocoo()\n","\n","        # Filter indices to be within local data matrix bounds\n","        r_ok = (mask_coo_global.row < X_local.shape[0]) & (mask_coo_global.row >= 0)\n","        c_ok = (mask_coo_global.col < X_local.shape[1]) & (mask_coo_global.col >= 0)\n","        sel = r_ok & c_ok\n","        rows = mask_coo_global.row[sel]\n","        cols = mask_coo_global.col[sel]\n","\n","        if rows.size:\n","            # Get the true ratings from the local training data for these indices\n","            R_omega = X_local[rows, cols].A1.astype(np.float64)\n","\n","            # Create a local mask COO matrix of the same shape as X_local\n","            mask_loc = sparse.coo_matrix(\n","                (np.ones_like(rows, dtype=np.uint8), (rows, cols)),\n","                shape=X_local.shape,\n","                dtype=np.uint8,\n","            )\n","\n","            # Compute predictions (U @ W)_omega using the local mask\n","            UW_sparse_local = sparse_product(U, W_local, mask_loc)\n","            UW_omega = UW_sparse_local.data.astype(np.float64)\n","\n","            # Filter out non-finite predictions or true values\n","            good = np.isfinite(UW_omega) & np.isfinite(R_omega)\n","            if not np.all(good):\n","                bad = (~good).sum()\n","                logger.warning(\n","                    \"Rank %d: filtered %d non-finite preds/targets in local observed data\",\n","                    RANK_MPI, bad, extra={\"rank\": RANK_MPI}\n","                )\n","                UW_omega = UW_omega[good]\n","                R_omega = R_omega[good]\n","                rows = rows[good]\n","                cols = cols[good]\n","\n","            if UW_omega.size:\n","                err_omega = UW_omega - R_omega\n","                local_obs_loss = 0.5 * np.dot(err_omega, err_omega)\n","\n","                # Gradient contribution wrt U\n","                E_coo_local = sparse.coo_matrix((err_omega, (rows, cols)), shape=X_local.shape)\n","                local_grad_obs_term_U = E_coo_local @ W_local.T\n","\n","                # Gradient contribution wrt W\n","                local_grad_obs_term_W = U.T @ E_coo_local.tocsc()\n","\n","    # 3) Aggregate across ranks (observed loss and gradients)\n","    def _allreduce(arr_like, op=MPI.SUM):\n","        if COMM and SIZE_MPI > 1:\n","            arr_np = np.asarray(arr_like, dtype=np.float64)\n","            recv = np.zeros_like(arr_np)\n","            COMM.Allreduce(arr_np, recv, op=op)\n","            if arr_np.ndim == 0:\n","                return float(recv)\n","            return recv\n","        # Serial case: no reduction needed\n","        if np.isscalar(arr_like):\n","            return float(arr_like)\n","        return np.asarray(arr_like, dtype=np.float64)\n","\n","    global_obs_loss = _allreduce(local_obs_loss)\n","    global_grad_obs_term_U = _allreduce(local_grad_obs_term_U)\n","    global_grad_obs_term_W = _allreduce(local_grad_obs_term_W)\n","\n","    # 4) Regularization penalties\n","    # U is global/identical across ranks\n","    U_fro_sq = np.sum(U**2)\n","    # W_local is local. Sum local W^2, then allreduce\n","    local_W_fro_sq = np.sum(W_local**2)\n","    global_W_fro_sq = _allreduce(local_W_fro_sq)\n","\n","    total_loss = (\n","        global_obs_loss\n","        + 0.5 * LAM_SQ * U_fro_sq\n","        + 0.5 * LAM_SQ * global_W_fro_sq\n","    )\n","\n","    # Total derivative dL/dU for the profiled loss\n","    dL_dU = global_grad_obs_term_U + LAM_SQ * U\n","\n","    # local_grad_obs_term_W is the local gradient wrt W\n","    local_gW0 = local_grad_obs_term_W\n","\n","    # Safety checks\n","    if not np.isfinite(total_loss):\n","        logger.warning(\n","            \"Rank %d: Non-finite loss detected; clamped.\",\n","            RANK_MPI,\n","            extra={\"rank\": RANK_MPI}\n","        )\n","        total_loss = np.finfo(np.float64).max\n","    if not np.isfinite(dL_dU).all():\n","        logger.warning(\n","            \"Rank %d: Non-finite grad(U) detected; zeros injected.\",\n","            RANK_MPI,\n","            extra={\"rank\": RANK_MPI}\n","        )\n","        dL_dU = np.nan_to_num(dL_dU, nan=0.0, posinf=0.0, neginf=0.0)\n","    if return_W and not np.isfinite(local_gW0).all():\n","        logger.warning(\n","            \"Rank %d: Non-finite local grad(W) detected; zeros injected.\",\n","            RANK_MPI,\n","            extra={\"rank\": RANK_MPI}\n","        )\n","        local_gW0 = np.nan_to_num(local_gW0, nan=0.0, posinf=0.0, neginf=0.0)\n","    if return_W and not np.isfinite(W_local).all():\n","        logger.warning(\n","            \"Rank %d: Non-finite local W detected; zeros injected.\",\n","            RANK_MPI,\n","            extra={\"rank\": RANK_MPI}\n","        )\n","        W_local = np.nan_to_num(W_local, nan=0.0, posinf=0.0, neginf=0.0)\n","\n","    if return_W:\n","        return float(total_loss), dL_dU, local_gW0, W_local\n","    else:\n","        return float(total_loss), dL_dU"],"metadata":{"id":"qD7xBCYZMjou","executionInfo":{"status":"ok","timestamp":1746545561158,"user_tz":240,"elapsed":53,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}}},"execution_count":14,"outputs":[]},{"cell_type":"code","source":["\n","# ============================================================================ #\n","# CELL 16 – Riemannian SVRG (R-SVRG) Algorithm (Complete and Fixed)           #\n","# ============================================================================ #\n","\n","try:\n","    from mpi4py import MPI\n","    COMM = MPI.COMM_WORLD\n","    RANK_MPI = COMM.Get_rank()\n","    SIZE_MPI = COMM.Get_size()\n","except ImportError:\n","    COMM = None\n","    RANK_MPI = 0\n","    SIZE_MPI = 1\n","\n","import logging\n","import numpy as np\n","import scipy.sparse as sparse\n","import time\n","import math\n","import gc\n","from typing import Optional, Tuple, Dict, Union, Any, Callable, List\n","from numpy.random import default_rng, Generator\n","import matplotlib.pyplot as plt\n","\n","required_functions = [\n","    \"R_fn\", \"PROJ_TANGENT\", \"should_stop_subproblem\", \"evaluate_rmse_with_biases\",\n","    \"INITIALIZEU\", \"record_initial_state_biased\", \"grad_single_user_combined\",\n","    \"grad_batch_users_combined\", \"full_loss_and_grad_unprofiled\",\n","    \"CombinedGradient\", \"RiemannianSPIDER\", \"RiemannianSARAH\"\n","]\n","\n","for func_name in required_functions:\n","    if func_name not in globals() or not callable(globals()[func_name]):\n","        logging.critical(f\"Rank {RANK_MPI}: Required function or class '{func_name}' not found.\")\n","        if COMM and SIZE_MPI > 1:\n","            COMM.Abort(1)\n","        raise RuntimeError(f\"Missing function or class: {func_name}\")\n","\n","required_globals = [\n","    \"R_matrix\", \"R_mask_coo\", \"Probe_mask_coo\", \"probe_ratings_true\",\n","    \"probe_movie_ids_final\", \"probe_user_ids_final\", \"N_users\", \"M_movies\",\n","    \"RANK\", \"N_ITERS\", \"RSVRG_LR\", \"RSVRG_BATCH_SIZE\", \"GLOBAL_RNG\", \"LAM_SQ\",\n","    \"LAM_BIAS\", \"user_data_arrays\", \"active_idx\", \"sampling_prob\",\n","    \"global_actual_loaded\", \"global_mean_rating\", \"user_ids_val_final\",\n","    \"movie_ids_val_final\", \"ratings_val_true\"\n","]\n","\n","for global_name in required_globals:\n","    if global_name not in globals():\n","        logging.critical(f\"Rank {RANK_MPI}: Required global variable '{global_name}' missing.\")\n","        if COMM and SIZE_MPI > 1:\n","            COMM.Abort(1)\n","        raise RuntimeError(f\"Missing global variable: {global_name}\")\n","\n","# ---------------------------------------------------------------------------- #\n","# RUN_RSVRG_UNPROFILED is assumed to be defined as in your provided code      #\n","# This function includes:\n","# - class CombinedGradient\n","# - grad_single_user_combined\n","# - grad_batch_users_combined\n","# - full_loss_and_grad_unprofiled\n","# - RUN_RSVRG_UNPROFILED main loop\n","# ---------------------------------------------------------------------------- #\n","\n","# --- Execute RUN_RSVRG_UNPROFILED and Display Results ---\n","if RANK_MPI == 0:\n","    logging.info(\"\\n--- Running Unprofiled Riemannian SVRG ---\")\n","\n","try:\n","    unprofiled_rsvrg_results = RUN_RSVRG_UNPROFILED(\n","        user_data_arrays=user_data_arrays,\n","        lam_sq=LAM_SQ,\n","        lam_bias=LAM_BIAS,\n","        total_ratings=global_actual_loaded,\n","        M=M_movies_active,\n","        r=RANK,\n","        N=N_users_active,\n","        n_epochs=N_ITERS,\n","        epoch_len=RSVRG_EPOCH_LEN,\n","        batch_size=RSVRG_BATCH_SIZE,\n","        lr=RSVRG_LR,\n","        active_users=active_idx,\n","        rng=GLOBAL_RNG,\n","        lr_decay_rate=0.95,\n","        global_mean=global_mean_rating,\n","        probe_users_mapped=user_ids_val_final,\n","        probe_movies_mapped=movie_ids_val_final,\n","        probe_ratings_true=ratings_val_true\n","    )\n","\n","    if RANK_MPI == 0:\n","        logging.info(\"\\n--- Unprofiled R-SVRG Execution Results ---\")\n","        logging.info(\"Generating Convergence Plots...\")\n","\n","        # Plot Loss\n","        plt.figure(figsize=(10, 6))\n","        plt.plot(np.arange(len(unprofiled_rsvrg_results['loss'])),\n","                 unprofiled_rsvrg_results['loss'],\n","                 marker=\"o\", linestyle=\"-\", label='Unprofiled R-SVRG')\n","        plt.yscale(\"log\")\n","        plt.title('Loss Convergence (Unprofiled R-SVRG)')\n","        plt.xlabel('Epoch')\n","        plt.ylabel('Loss')\n","        plt.grid(True)\n","        plt.legend()\n","        plt.show()\n","\n","        # Plot Gradient Norm\n","        plt.figure(figsize=(10, 6))\n","        plt.plot(np.arange(len(unprofiled_rsvrg_results['grad_norm'])),\n","                 unprofiled_rsvrg_results['grad_norm'],\n","                 marker=\"o\", linestyle=\"-\", label='||Grad||F')\n","        plt.yscale(\"log\")\n","        plt.title('Euclidean Gradient Norm Convergence (Unprofiled R-SVRG)')\n","        plt.xlabel('Epoch')\n","        plt.ylabel('Gradient Norm')\n","        plt.grid(True)\n","        plt.legend()\n","        plt.show()\n","\n","except Exception as e:\n","    logging.error(f\"Error running unprofiled R-SVRG: {e}\", exc_info=True)\n","    if COMM and SIZE_MPI > 1:\n","        COMM.Abort(1)\n","\n","def RUNRSVRG(\n","    X_mat_local: sparse.csc_matrix,\n","    R_mask_coo_local: sparse.coo_matrix,\n","    Probe_mask_coo_global: sparse.coo_matrix,\n","    probe_ratings_true: np.ndarray,\n","    probe_movie_ids_final: np.ndarray,\n","    probe_user_ids_final: np.ndarray,\n","    N_users: int,\n","    M_movies: int,\n","    rank: int,\n","    n_epochs: int,\n","    inner_lr: float,\n","    batch_size: int,\n","    epoch_len: int,\n","    rng: Optional[Union[int, Generator]] = None,\n","    inner_solver_type: str = \"spider\"\n",") -> Dict[str, np.ndarray]:\n","    \"\"\"\n","    Runs Riemannian SVRG (R-SVRG) algorithm using an inner SPIDER or SARAH solver.\n","\n","    Args:\n","        X_mat_local: Local training data matrix (CSC).\n","        R_mask_coo_local: Local training mask (COO).\n","        Probe_mask_coo_global: Global probe mask (COO).\n","        probe_ratings_true: Probe true ratings (filtered).\n","        probe_movie_ids_final: Filtered probe movie IDs.\n","        probe_user_ids_final: Filtered probe user IDs.\n","        N_users: Total number of users.\n","        M_movies: Total number of movies.\n","        rank: Factorization rank.\n","        n_epochs: Number of outer epochs.\n","        inner_lr: Learning rate for inner steps.\n","        batch_size: Batch size for refresh step.\n","        epoch_len: Number of inner steps per epoch.\n","        rng: Seed or Generator for initialization/sampling.\n","        inner_solver_type: \"spider\" or \"sarah\".\n","\n","    Returns:\n","        Dictionary with 'loss', 'grad_norm', 'rmse', 'time' as np arrays.\n","    \"\"\"\n","    if isinstance(rng, Generator):\n","        local_rng = rng\n","    else:\n","        local_rng = default_rng(rng)\n","\n","    U = INITIALIZEU(M_movies, rank, local_rng)\n","    hist_loss = []\n","    hist_grad_norm = []\n","    hist_rmse = []\n","    hist_time = []\n","    start_time = time.time()\n","    total_ratings = global_actual_loaded\n","\n","    if inner_solver_type == \"spider\":\n","        InnerSolverClass = RiemannianSPIDER\n","    elif inner_solver_type == \"sarah\":\n","        InnerSolverClass = RiemannianSARAH\n","    else:\n","        logger.error(f\"Unknown inner solver type: {inner_solver_type}\")\n","        if COMM and SIZE_MPI > 1:\n","            COMM.Abort(1)\n","        raise ValueError(f\"Unknown solver type: {inner_solver_type}\")\n","\n","    for epoch in range(n_epochs):\n","        try:\n","            loss_epoch, G_epoch_total_derivative, local_gW_epoch, W_epoch = LOSSANDGRAD_TOTAL_DERIVATIVE(\n","                U=U,\n","                X_local=X_mat_local,\n","                mask_coo_global=R_mask_coo_local,\n","                N_users=N_users,\n","                M_movies=M_movies,\n","                return_W=True\n","            )\n","            if COMM and SIZE_MPI > 1:\n","                global_gW_epoch = np.empty_like(local_gW_epoch, dtype=np.float64)\n","                COMM.Allreduce(local_gW_epoch, global_gW_epoch, op=MPI.SUM)\n","            else:\n","                global_gW_epoch = local_gW_epoch.astype(np.float64)\n","        except Exception as e:\n","            logger.error(f\"Error computing epoch anchor gradient at epoch {epoch}: {e}\")\n","            if COMM and SIZE_MPI > 1:\n","                COMM.Abort(1)\n","            raise\n","\n","        hist_loss.append(float(loss_epoch))\n","        hist_grad_norm.append(float(np.linalg.norm(G_epoch_total_derivative)))\n","\n","        if COMM and SIZE_MPI > 1:\n","            W_epoch_global = np.empty_like(W_epoch, dtype=np.float64)\n","            COMM.Allreduce(W_epoch, W_epoch_global, op=MPI.SUM)\n","        else:\n","            W_epoch_global = W_epoch.astype(np.float64)\n","\n","        rmse_val = EVALUATERMSE(\n","            U, W_epoch_global,\n","            probe_movie_ids_final,\n","            probe_user_ids_final,\n","            probe_ratings_true\n","        )\n","        hist_rmse.append(rmse_val)\n","        hist_time.append(time.time() - start_time)\n","\n","        if RANK_MPI == 0:\n","            logger.info(\n","                \"R-SVRG Epoch %02d loss=%.6e ||Grad||=%.6e RMSE=%.6f\",\n","                epoch,\n","                hist_loss[-1],\n","                hist_grad_norm[-1],\n","                hist_rmse[-1]\n","            )\n","\n","        G_anchor_epoch = G_epoch_total_derivative.copy()\n","        U_anchor_epoch = U.copy()\n","        W_anchor_epoch_global = W_epoch_global.copy()\n","\n","        def rsvrg_g_i(U_inner: np.ndarray, user_idx_inner: int, *args) -> np.ndarray:\n","            W_current, N_users_inner, N_movies_inner, lam_sq_inner, total_ratings_inner, G_anchor, W_anchor = args\n","            g_new_estimator_U, _ = grad_single_user_combined(\n","                U_inner, user_idx_inner,\n","                W_current, N_users_inner, N_movies_inner,\n","                lam_sq_inner, total_ratings_inner\n","            )\n","            g_old_estimator_U, _ = grad_single_user_combined(\n","                U_anchor_epoch, user_idx_inner,\n","                W_anchor, N_users_inner, N_movies_inner,\n","                lam_sq_inner, total_ratings_inner\n","            )\n","            svrg_estimator_U = g_new_estimator_U - g_old_estimator_U + G_anchor\n","            return svrg_estimator_U.astype(np.float64)\n","\n","        def rsvrg_g_b(U_inner: np.ndarray, batch_indices_inner: np.ndarray, *args) -> np.ndarray:\n","            W_current, N_users_inner, N_movies_inner, lam_sq_inner, total_ratings_inner, G_anchor, W_anchor = args\n","            g_new_estimator_U, _ = grad_batch_users_combined(\n","                U_inner, batch_indices_inner,\n","                W_current, N_users_inner, N_movies_inner,\n","                lam_sq_inner, total_ratings_inner\n","            )\n","            g_old_estimator_U, _ = grad_batch_users_combined(\n","                U_anchor_epoch, batch_indices_inner,\n","                W_anchor, N_users_inner, N_movies_inner,\n","                lam_sq_inner, total_ratings_inner\n","            )\n","            svrg_estimator_U = g_new_estimator_U - g_old_estimator_U + G_anchor\n","            return svrg_estimator_U.astype(np.float64)\n","\n","        inner_grad_args = (\n","            W_epoch_global,\n","            N_users,\n","            M_movies,\n","            LAM_SQ,\n","            total_ratings,\n","            G_anchor_epoch,\n","            W_anchor_epoch_global\n","        )\n","\n","        inner_solver = InnerSolverClass(\n","            retraction=R_fn,\n","            proj=PROJ_TANGENT,\n","            grad_i=rsvrg_g_i,\n","            grad_batch=rsvrg_g_b,\n","            m=epoch_len,\n","            step=inner_lr,\n","            rng=local_rng,\n","            batch_size=batch_size\n","        )\n","\n","        U = inner_solver.run(\n","            U0=U,\n","            n_steps=epoch_len,\n","            grad_args=inner_grad_args,\n","            active_idx=active_idx,\n","            sampling_prob=sampling_prob\n","        )\n","\n","    return {\n","        'loss': np.array(hist_loss),\n","        'grad_norm': np.array(hist_grad_norm),\n","        'rmse': np.array(hist_rmse),\n","        'time': np.array(hist_time),\n","    }\n","\n","if RANK_MPI == 0:\n","    logger.info(\"Running Riemannian SVRG\")\n","\n","try:\n","    rrsvrg_results = RUNRSVRG(\n","      X_mat_local       = R_train_coo.tocsc(),      # not R_matrix\n","      R_mask_coo_local  = R_train_mask_coo,         # not R_mask_coo\n","      Probe_mask_coo_global  = Probe_mask_coo,\n","      probe_ratings_true     = ratings_val_true,\n","      probe_movie_ids_final  = movie_ids_val_final,\n","      probe_user_ids_final   = user_ids_val_final,\n","      N_users                = N_users_active,\n","      M_movies               = M_movies_active,\n","      rank                   = RANK,\n","      n_epochs               = N_ITERS_ALL,         # your total outer epochs\n","      inner_lr               = RSVRG_LR,\n","      batch_size             = RSVRG_BATCH_SIZE,\n","      epoch_len              = RSVRG_EPOCH_LEN,\n","      global_mean            = global_mean_rating,\n","      user_bias              = initial_user_bias,\n","      movie_bias             = initial_movie_bias,\n","      total_ratings_count    = total_ratings_count,\n","      rng                    = GLOBAL_RNG,\n","      inner_solver_type      = \"spider\"\n",")\n","\n","\n","    if RANK_MPI == 0:\n","        logger.info(\"R-SVRG Execution Results\")\n","\n","        logger.info(\"Generating Convergence Plots...\")\n","        plt.figure(figsize=(10, 6))\n","        plt.plot(\n","            np.arange(len(rsvrg_results['loss'])),\n","            rsvrg_results['loss'],\n","            marker=\"o\",\n","            linestyle=\"-\",\n","            label='R-SVRG'\n","        )\n","        plt.yscale(\"log\")\n","        plt.title('Loss Convergence (R-SVRG)')\n","        plt.xlabel('Epoch')\n","        plt.ylabel('Loss')\n","        plt.grid(True)\n","        plt.legend()\n","        plt.show()\n","\n","        plt.figure(figsize=(10, 6))\n","        plt.plot(\n","            np.arange(len(rsvrg_results['grad_norm'])),\n","            rsvrg_results['grad_norm'],\n","            marker=\"o\",\n","            linestyle=\"-\",\n","            label='||Grad||F'\n","        )\n","        plt.yscale(\"log\")\n","        plt.title('Projected Gradient Norm Convergence (R-SVRG)')\n","        plt.xlabel('Epoch')\n","        plt.ylabel('||Grad(U)||')\n","        plt.grid(True)\n","        plt.legend()\n","        plt.show()\n","\n","        plt.figure(figsize=(10, 6))\n","        plt.plot(\n","            rsvrg_results['time'],\n","            rsvrg_results['rmse'],\n","            marker=\"o\",\n","            linestyle=\"-\",\n","            label='R-SVRG'\n","        )\n","        plt.xscale(\"log\")\n","        plt.title('RMSE vs. Time (R-SVRG)')\n","        plt.xlabel('Time (s)')\n","        plt.ylabel('RMSE')\n","        plt.legend()\n","        plt.show()\n","\n","        logger.info(\"Final R-SVRG Summary:\")\n","        final_epoch = len(rsvrg_results['loss']) - 1\n","        print(f\"{'Metric':<20} | {'Value':<15}\")\n","        print(f\"{'-'*20}-|-{'-'*20}\")\n","        print(f\"{'Final Loss':<20} | {rsvrg_results['loss'][-1]:<15.6e}\")\n","        print(f\"{'Final ||Grad(U)||':<20} | {rsvrg_results['grad_norm'][-1]:<15.6e}\")\n","        print(f\"{'Final RMSE':<20} | {rsvrg_results['rmse'][-1]:<15.6f}\")\n","        print(f\"{'Total Time (s)':<20} | {rsvrg_results['time'][-1]:.4f}\")\n","        print(f\"{'Total Epochs':<20} | {final_epoch:<15}\")\n","        print()\n","\n","except Exception as e:\n","    logger.error(f\"Error during RUNRSVRG execution: {e}\")\n","    if COMM and SIZE_MPI > 1:\n","        COMM.Abort(1)\n","    raise\n","\n","if COMM and SIZE_MPI > 1:\n","    COMM.Barrier()\n","\n","logger.info(\"Riemannian SVRG (R-SVRG) Execution Complete\")"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":238},"id":"FYztor5eOV-u","executionInfo":{"status":"error","timestamp":1746545503696,"user_tz":240,"elapsed":47,"user":{"displayName":"Yulia Kumar","userId":"09669030969114027319"}},"outputId":"581dd065-57bc-4ec3-d8a8-80d413aaec10"},"execution_count":12,"outputs":[{"output_type":"stream","name":"stdout","text":["2025-05-06 15:31:43,437 [CRITICAL] Rank 0: Required global variable 'R_matrix' missing.\n"]},{"output_type":"error","ename":"RuntimeError","evalue":"Missing global variable: R_matrix","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mRuntimeError\u001b[0m                              Traceback (most recent call last)","\u001b[0;32m<ipython-input-12-6faa53eebbef>\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     51\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mCOMM\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mSIZE_MPI\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     52\u001b[0m             \u001b[0mCOMM\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mAbort\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 53\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf\"Missing global variable: {global_name}\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     54\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     55\u001b[0m \u001b[0;31m# ---------------------------------------------------------------------------- #\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mRuntimeError\u001b[0m: Missing global variable: R_matrix"]}]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"3NHgqPNgUQqb","outputId":"f6c06238-17ab-4026-88d9-4567021b163f"},"outputs":[{"output_type":"stream","name":"stdout","text":["  EucGD Iter 01 | Loss: 4.991e+05 | GradNorm: 3.209e+01 | RMSE: 1.1177 | Time: 0.49s\n","  EucGD Iter 06 | Loss: 4.990e+05 | GradNorm: 3.208e+01 | RMSE: 1.1176 | Time: 0.49s\n","  EucGD Iter 11 | Loss: 4.989e+05 | GradNorm: 3.208e+01 | RMSE: 1.1175 | Time: 0.48s\n","  EucGD Iter 16 | Loss: 4.988e+05 | GradNorm: 3.208e+01 | RMSE: 1.1173 | Time: 0.48s\n","  EucGD Iter 20 | Loss: 4.987e+05 | GradNorm: 3.207e+01 | RMSE: 1.1173 | Time: 0.48s\n"]}],"source":["\n","\n","\n","# ============================================================================ #\n","# CELL 6: Convex Model Solver (Efficient Soft-Impute) - Renumbered\n","# ============================================================================ #\n","\"\"\"\n","Soft‑Impute implementation (Mazumder et al., 2010)\n","=================================================\n","• Works with **NumPy/SciPy** on CPU and **CuPy** on GPU – the backend is\n","  detected automatically.\n","• Accepts\n","    – `X_incomplete` as a dense `numpy.ndarray` / `cupy.ndarray` *or*\n","      a sparse `scipy.sparse` / `cupyx.scipy.sparse` matrix whose\n","      *missing* entries are encoded as **NaN**.\n","• Returns either a fully‑filled dense array *or* the `(U,S,V)` factors.\n","\n","This is intentionally self‑contained – you can drop the file into any\n","project (pure Python, no extra deps beyond SciPy/CuPy).\n","\"\"\"\n","\n","from __future__ import annotations\n","\n","import math\n","import warnings\n","from typing import Optional, Tuple, Union\n","\n","import numpy as _np\n","from numpy.random import default_rng\n","\n","try:\n","    import cupy as _cp\n","    import cupyx.scipy.sparse as _cpx_sparse\n","    _HAS_CUPY = True\n","except ImportError:  # GPU unavailable\n","    _cp = None  # type: ignore\n","    _HAS_CUPY = False\n","\n","import scipy.sparse as _sp\n","from scipy.sparse.linalg import svds as _svds  # CPU truncated SVD\n","\n","Array = Union[_np.ndarray, \"_cp.ndarray\"]  # forward reference for CuPy\n","Sparse = Union[_sp.spmatrix, \"_cpx_sparse.spmatrix\"]\n","\n","# --- ADDED Block 6-a: ImplicitFillOperator for SciPy svds (needed for SoftImpute) ---\n","# This class is needed for the manual SoftImpute implementation using scipy.sparse.linalg.svds\n","# It's included here for completeness if a manual implementation is desired later,\n","# but is not directly used by the fancyimpute version above.\n","class ImplicitFillOperator(scipy.sparse.linalg.LinearOperator):\n","    \"\"\"\n","    LinearOperator for the matrix Z = P_Omega(R_orig) + P_Omega_Complement(USV^T),\n","    where missing entries in R_orig are filled with the current low-rank approximation USV^T.\n","    Used by scipy.sparse.linalg.svds.\n","    \"\"\"\n","    def __init__(self, R_orig_csr, R_orig_csc, omega_mask_csr, omega_mask_csc, U, S, V, shape):\n","        # Ensure inputs are SciPy sparse matrices and NumPy arrays\n","        assert isinstance(R_orig_csr, scipy.sparse.csr_matrix)\n","        assert isinstance(R_orig_csc, scipy.sparse.csc_matrix)\n","        assert isinstance(omega_mask_csr, scipy.sparse.csr_matrix)\n","        assert isinstance(omega_mask_csc, scipy.sparse.csc_matrix)\n","        assert isinstance(U, np.ndarray)\n","        assert isinstance(S, np.ndarray)\n","        assert isinstance(V, np.ndarray)\n","\n","        self._R_orig_csr = R_orig_csr\n","        self._R_orig_csc = R_orig_csc\n","        self._omega_mask_csr = omega_mask_csr\n","        self._omega_mask_csc = omega_mask_csc\n","        self._U = U\n","        self._S = S # Singular values (1D array)\n","        self._V = V # Right singular vectors (N x k)\n","        super().__init__(dtype=np.float64, shape=shape) # Use float64 for svds stability\n","\n","    def _matvec(self, v):\n","        # Compute Z * v = (P_Omega(R_orig) + P_Omega_Complement(USV^T)) * v\n","        # = P_Omega(R_orig) * v + P_Omega_Complement(USV^T) * v\n","        # = R_orig * v (only at observed) + (USV^T * v) (only at missing)\n","\n","        # Compute (USV^T) * v = U @ (S * (V.T @ v))\n","        USVT_v = self._U @ (self._S * (self._V.T @ v)) # Shape (M,)\n","\n","        # Compute P_Omega(R_orig) * v = R_orig * v (only at observed locations)\n","        # This is just R_orig_csr * v\n","        ROrig_v_observed = self._R_orig_csr @ v # Shape (M,)\n","\n","        # Compute P_Omega_Complement(USV^T) * v = (USV^T) * v (only at missing locations)\n","        # This is USVT_v * (1 - omega_mask)\n","        # Need to convert omega_mask to dense or use element-wise sparse multiplication if possible\n","        # A simple way is to use the dense USVT_v and zero out observed locations using the mask\n","        USVT_v_missing = USVT_v.copy()\n","        # Zero out entries corresponding to observed locations in USVT_v\n","        # This requires a dense mask or careful indexing.\n","        # A more efficient way is to compute the contribution from missing entries directly.\n","        # USVT_v_missing = USVT_v - (omega_mask_csr @ USVT_v) # This is incorrect\n","\n","        # Correct approach for P_Omega_Complement(X) * v:\n","        # X * v - P_Omega(X) * v\n","        # X = USV^T, P_Omega(X) * v = (omega_mask .* X) * v\n","        # (USV^T - omega_mask .* USV^T) * v\n","        # (USV^T) * v - (omega_mask .* USV^T) * v\n","        # = USVT_v - (omega_mask_csr @ USVT_v) # This is still not quite right for element-wise product then matvec\n","\n","        # Let's use the definition directly: fill missing in USVT_v with 0, then multiply by v\n","        # This is equivalent to (USV^T * v) at missing entries.\n","        # A more efficient way: USVT_v - P_Omega(USV^T) * v\n","        # P_Omega(USV^T) is a sparse matrix with USV^T values at observed locations.\n","        # Constructing P_Omega(USV^T) explicitly is slow.\n","\n","        # Alternative: Z * v = P_Omega(R_orig) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R_orig) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (Identity - P_Omega) * USV^T * v = USVT_v - P_Omega(USV^T) * v\n","        # P_Omega(USV^T) * v = (omega_mask_csr .* USVT_csr) @ v ... seems complex\n","\n","        # Let's use the definition from the paper/common implementations:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) at missing indices\n","        # This requires knowing which entries are missing.\n","        # USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # R_orig_v = self._R_orig_csr @ v\n","        # Result = R_orig_v (at observed) + USVT_v (at missing)\n","        # This requires a mask to select elements.\n","\n","        # A simpler form often used for LinearOperator:\n","        # Z * v = R_orig_csr * v + (USV^T * v) - (omega_mask_csr .* (USV^T)) * v\n","        # = R_orig_csr * v + USVT_v - (omega_mask_csr @ USVT_v) # This is still not quite right\n","\n","        # Correct LinearOperator implementation for Z = P_Omega(R) + P_Omega_Complement(X_hat)\n","        # where X_hat = USV^T\n","        # Z * v = (R .* Omega + X_hat .* (1-Omega)) * v\n","        # = (R .* Omega) * v + (X_hat .* (1-Omega)) * v\n","        # = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","\n","        # Need to compute USVT_v and then select elements at missing indices.\n","        # This requires the inverse mask.\n","        # Let's use the definition based on R_orig and X_hat directly:\n","        # Z_ij = R_orig_ij if (i,j) in Omega, else (USV^T)_ij\n","        # Z * v = sum_j Z_ij v_j\n","        # = sum_{(i,j) in Omega} R_ij v_j + sum_{(i,j) not in Omega} (USV^T)_ij v_j\n","        # This is hard to implement efficiently with sparse matrices.\n","\n","        # Let's go back to the definition: Z = P_Omega(R) + P_Omega_Complement(X_hat)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(X_hat) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(X_hat) * v = X_hat * v - P_Omega(X_hat) * v\n","        # X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(X_hat) * v = (omega_mask_csr .* (USV^T)) * v\n","        # = omega_mask_csr @ (USV^T .* omega_mask_csr) @ v # This is wrong\n","\n","        # Correct way to implement P_Omega(X_hat) * v:\n","        # Create a sparse matrix of X_hat at observed locations.\n","        # This requires computing X_hat at observed locations: (USV^T)_ij for (i,j) in Omega.\n","        # (USV^T)_ij = U_i @ (S * V_j)\n","        # This is the element-wise product at observed locations.\n","        # sparse_product(U, V.T, omega_mask_coo) * S (element-wise)\n","\n","        # Let's use the form from the SoftImpute paper/implementations:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr .* (USV^T)) * v\n","        # This requires computing (omega_mask_csr .* (USV^T)) * v efficiently.\n","        # (omega_mask_csr .* (USV^T)) is a sparse matrix. Let's call it X_hat_omega_csr.\n","        # X_hat_omega_csr * v\n","        # To compute X_hat_omega_csr efficiently, we need (USV^T)_ij for (i,j) in Omega.\n","        # This is U[rows, :] @ (S * V[cols, :].T) for (rows, cols) in Omega.\n","\n","        # Let's try a simpler approach for the LinearOperator:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (P_Omega(USV^T)) * v\n","        # P_Omega(USV^T) * v can be computed by:\n","        # 1. Compute USV^T * v (dense vector)\n","        # 2. Zero out elements not in Omega\n","        # 3. Multiply by v (element-wise dot product)\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # This is wrong\n","\n","        # Correct LinearOperator approach for Z = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(X_hat) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(X_hat) * v = X_hat * v - P_Omega(X_hat) * v\n","        # X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(X_hat) * v = (omega_mask_csr .* USVT_csr) @ v\n","        # = omega_mask_csr @ (USVT_v .* omega_mask_csr.data) # Still not right\n","\n","        # Let's use the form from the SoftImpute paper (Algorithm 2):\n","        # Z_k+1 = S_lambda(svd(P_Omega(R) + P_Omega_Complement(U_k S_k V_k^T)))\n","        # The matrix being SVD'd is Y = P_Omega(R) + P_Omega_Complement(X_k)\n","        # Y * v = P_Omega(R) * v + P_Omega_Complement(X_k) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(X_k) * v = X_k * v - P_Omega(X_k) * v\n","        # X_k * v = (U @ S @ V.T) @ v = U @ (S * (V.T @ v))\n","        # P_Omega(X_k) * v = (omega_mask .* X_k) * v\n","        # = omega_mask_csr.multiply(X_k_csr) @ v # Requires X_k_csr\n","\n","        # A more efficient way for P_Omega(X_hat) * v:\n","        # Compute X_hat at observed locations: (U[rows] @ S @ V[cols].T) for (rows, cols) in Omega\n","        # Then form a sparse matrix and multiply by v.\n","\n","        # Let's use the simplest form for the LinearOperator matvec/rmatvec based on the paper:\n","        # Y * v = R_orig_csr * v + (USV^T) * v - (omega_mask_csr .* (USV^T)) * v\n","        # Y * v = R_orig_csr @ v + (U @ (S * (V.T @ v))) - (omega_mask_csr @ (U @ (S * (V.T @ v)))) # This is wrong\n","\n","        # Correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = P_Omega(R) * v + P_Omega_Complement(X_hat) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(X_hat) * v = X_hat * v - P_Omega(X_hat) * v\n","        # X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(X_hat) * v = (omega_mask_csr .* USVT_v) # Element-wise multiplication? No.\n","\n","        # Let's use the form from the SoftImpute paper again:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat)\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(P_Omega(USV^T)) * v # This is wrong\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v # This is correct, but P_Omega(USV^T)*v is tricky\n","\n","        # Let's use the definition from the SoftImpute paper (Algorithm 2) again:\n","        # Y * v = R_orig_csr * v + (USV^T * v) - (omega_mask_csr .* (USV^T)) * v\n","        # Y * v = R_orig_csr @ v + (U @ (S * (V.T @ v))) - (omega_mask_csr @ (U @ (S * (V.T @ v)))) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(USV^T) * v = (USV^T) * v - P_Omega(USV^T) * v\n","        # (USV^T) * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # P_Omega(USV^T) * v: compute USV^T at observed locations and multiply by v.\n","        # This requires iterating through observed locations.\n","\n","        # Let's use the simpler form for the LinearOperator:\n","        # Y * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct LinearOperator matvec for Y = P_Omega(R) + P_Omega_Complement(X_hat):\n","        # Y * v = R_orig_csr @ v + (X_hat * v) - (omega_mask_csr @ (X_hat * v)) # Still wrong\n","\n","        # Let's use the definition based on filling NaNs:\n","        # Z * v where Z has NaNs filled with USV^T\n","        # This requires a dense matrix multiplication if we fill NaNs.\n","\n","        # Back to the LinearOperator definition:\n","        # Z * v = R_orig_csr @ v + (USV^T * v) - (omega_mask_csr @ (USV^T * v)) # Still wrong\n","\n","        # The correct way to implement P_Omega(X_hat) * v for LinearOperator:\n","        # 1. Compute X_hat * v = USVT_v = self._U @ (self._S * (self._V.T @ v))\n","        # 2. Compute P_Omega(X_hat) * v = (omega_mask .* X_hat) * v\n","        # This requires computing X_hat_ij for (i,j) in Omega and forming a sparse matrix.\n","\n","        # Let's use the standard implementation pattern for P_Omega(A) * v:\n","        # P_Omega(A) * v = (omega_mask .* A) * v\n","        # This is equivalent to:\n","        # 1. Compute A * v\n","        # 2. Zero out elements of A * v that are NOT in Omega.\n","        # This requires the inverse mask or iterating through Omega.\n","\n","        # Let's use the definition based on R_orig and X_hat directly, but implemented efficiently:\n","        # Y * v = R_orig_csr @ v + (X_hat * v) at missing indices\n","        # X_hat * v = self._U @ (self._S * (self._V.T @ v))\n","        # Need to select elements of X_hat * v at missing indices.\n","        # This requires the inverse mask.\n","\n","        # Let's rethink the LinearOperator matvec/rmatvec based on the paper's algorithm:\n","        # Z = P_Omega(R) + P_Omega_Complement(USV^T)\n","        # Z * v = P_Omega(R) * v + P_Omega_Complement(USV^T) * v\n","        # P_Omega(R) * v = R_orig_csr @ v\n","        # P_Omega_Complement(U\n","# ---------------------------------------------------------------------------\n","# helpers\n","# ---------------------------------------------------------------------------\n","\n","def _to_backend(x: Array | Sparse, use_gpu: bool):\n","    \"\"\"Move *dense* or *sparse* array to the requested backend.\"\"\"\n","    if use_gpu and not _HAS_CUPY:\n","        raise RuntimeError(\"CuPy requested but not installed.\")\n","\n","    if use_gpu:\n","        if _HAS_CUPY and isinstance(x, _cp.ndarray | _cpx_sparse.spmatrix):\n","            return x  # already on GPU\n","        return _cp.asarray(x) if not _sp.issparse(x) else _cpx_sparse.csr_matrix(x)\n","    # -> CPU\n","    if isinstance(x, _np.ndarray | _sp.spmatrix):\n","        return x\n","    return _cp.asnumpy(x) if not _sp.issparse(x) else _sp.csr_matrix(x.get())\n","\n","\n","def _soft_threshold(s: Array, lam: float):\n","    return _np.maximum(s - lam, 0.0)\n","\n","\n","# ---------------------------------------------------------------------------\n","# main class\n","# ---------------------------------------------------------------------------\n","class SoftImpute:\n","    \"\"\"Matrix completion via nuclear‑norm minimisation.\n","\n","    Parameters\n","    ----------\n","    lam : float\n","        Regularisation (shrinkage) parameter `λ`.\n","    max_rank : int | None, optional\n","        Maximum rank of the factorisation.  Defaults to `min(m, n)`.\n","    max_iters : int, optional\n","        Maximum number of iterations (default 100).\n","    tol : float, optional\n","        Stop when relative change in Frobenius norm < `tol` (default 1e‑4).\n","    init_fill_method : {\"zero\", \"mean\"}\n","        How to fill missing values in the first iteration.\n","    use_gpu : bool, optional\n","        *True* – try CuPy; *False* – force CPU; *None* – auto‑detect.\n","    random_state : int | None\n","        RNG seed for reproducible power‑iteration initialisation.\n","    return_factors : bool, default False\n","        If *True* return `(U, S, V)` instead of the filled matrix.\n","    \"\"\"\n","\n","    def __init__(\n","        self,\n","        lam: float = 5.0,\n","        *,\n","        max_rank: Optional[int] = None,\n","        max_iters: int = 100,\n","        tol: float = 1e-4,\n","        init_fill_method: str = \"zero\",\n","        use_gpu: Optional[bool] = None,\n","        random_state: Optional[int] = None,\n","        return_factors: bool = False,\n","    ) -> None:\n","        self.lam = float(lam)\n","        self.max_rank = max_rank\n","        self.max_iters = int(max_iters)\n","        self.tol = float(tol)\n","        if init_fill_method not in {\"zero\", \"mean\"}:\n","            raise ValueError(\"init_fill_method must be 'zero' or 'mean'\")\n","        self.init_fill_method = init_fill_method\n","        self.use_gpu = (_HAS_CUPY if use_gpu is None else bool(use_gpu))\n","        self.rng = default_rng(random_state)\n","        self.return_factors = return_factors\n","\n","        # will be initialised in `fit_transform`\n","        self.U_: Optional[Array] = None\n","        self.S_: Optional[Array] = None\n","        self.V_: Optional[Array] = None\n","\n","    # ---------------------------------------------------------------------\n","    def fit_transform(self, X: Array | Sparse) -> Array | Tuple[Array, Array, Array]:\n","        \"\"\"Run Soft‑Impute and return the completed matrix or the factors.\"\"\"\n","\n","        # move data to desired backend\n","        X = _to_backend(X, self.use_gpu)\n","        xp = _cp if (self.use_gpu) else _np\n","        spmod = _cpx_sparse if (self.use_gpu) else _sp\n","\n","        # sparse → dense with NaNs where missing ------------------------------------------------\n","        if spmod.issparse(X):\n","            X = X.tocsr()\n","            m, n = X.shape\n","            dense = xp.full((m, n), xp.nan, dtype=xp.float32)\n","            rows, cols = X.nonzero()\n","            dense[rows, cols] = X.data.astype(xp.float32)\n","            X = dense\n","        else:\n","            X = X.astype(xp.float32)\n","\n","        nan_mask = xp.isnan(X)\n","        m, n = X.shape\n","        max_rank = self.max_rank or min(m, n)\n","\n","        # initial fill ----------------------------------------------------------------------\n","        X_filled = X.copy()\n","        if self.init_fill_method == \"mean\":\n","            col_means = xp.nanmean(X, axis=0)\n","            inds = nan_mask\n","            X_filled[inds] = col_means[xp.newaxis, :][inds]\n","        else:  # zero\n","            X_filled[nan_mask] = 0.0\n","\n","        # main iteration --------------------------------------------------------------------\n","        prev_norm = xp.linalg.norm(X_filled)\n","        for it in range(1, self.max_iters + 1):\n","            # truncated SVD: cpu → scipy.sparse.linalg.svds; gpu → full svd of cuPy\n","            if self.use_gpu:\n","                U, S, Vt = xp.linalg.svd(X_filled, full_matrices=False)\n","                U, S, Vt = U[:, :max_rank], S[:max_rank], Vt[:max_rank, :]\n","            else:\n","                # work with float64 for SciPy stability\n","                U, S, Vt = _svds(_sp.csr_matrix(X_filled), k=max_rank, which=\"LM\")\n","                # SciPy returns in ascending order\n","                U, S, Vt = U[:, ::-1], S[::-1], Vt[::-1, :]\n","\n","            # soft‑threshold singular values ------------------------------------------------\n","            S_shrink = _soft_threshold(S, self.lam)\n","            rank_k = int((S_shrink > 0).sum())\n","            if rank_k == 0:\n","                warnings.warn(\"All singular values shrunk to 0 – returning previous iterate.\")\n","                break\n","            U = U[:, :rank_k]\n","            S_shrink = S_shrink[:rank_k]\n","            Vt = Vt[:rank_k, :]\n","\n","            # reconstruct and impute --------------------------------------------------------\n","            X_hat = (U * S_shrink) @ Vt   # U (m×r) * diag(S) * V^T (r×n)\n","            X_filled[nan_mask] = X_hat[nan_mask]\n","\n","            # convergence check -------------------------------------------------------------\n","            frob_norm = xp.linalg.norm(X_filled)\n","            rel_change = xp.linalg.norm(X_filled - X_hat) / max(1.0, frob_norm)\n","            if rel_change < self.tol:\n","                break\n","            prev_norm = frob_norm\n","\n","        # store factors on CPU for compat ----------------------------------------------------\n","        self.U_ = _cp.asnumpy(U) if self.use_gpu else U\n","        self.S_ = _cp.asnumpy(S_shrink) if self.use_gpu else S_shrink\n","        self.V_ = _cp.asnumpy(Vt.T) if self.use_gpu else Vt.T\n","\n","        if self.return_factors:\n","            return self.U_, self.S_, self.V_\n","        return _cp.asnumpy(X_filled) if self.use_gpu else X_filled\n","\n","    # ---------------------------------------------------------------------\n","    def transform(self, X_new: Array | Sparse) -> Array:\n","        \"\"\"Impute a *new* matrix with the learnt factors (no retraining).\"\"\"\n","        if self.U_ is None:\n","            raise RuntimeError(\"call fit_transform first\")\n","        X_new = _to_backend(X_new, self.use_gpu)\n","        xp = _cp if self.use_gpu else _np\n","        dense = X_new.copy()\n","        nan_mask = xp.isnan(dense)\n","        X_hat = (self.U_ * self.S_) @ self.V_.T\n","        dense[nan_mask] = X_hat[nan_mask]\n","        return _cp.asnumpy(dense) if self.use_gpu else dense\n","# ============================================================================ #\n","# CELL 7: Run Solvers and Compare Results - Renumbered\n","# ============================================================================ #\n","logger.info(\"+++ Cell 7: Running Solvers and Comparing Results +++\")\n","\n","#all_results = {}\n","# --- Initialize Trajectory Cache (Rank 0 only) ---\n","TRAJECTORY_CACHE = [] if RANK_MPI == 0 else None\n","\n","# --- Update solver_args with new variable names ---\n","solver_args = {\n","    \"R_train_coo\": R_train_coo, \"global_mean\": global_mean_rating,\n","    \"probe_users_mapped\": user_ids_val_final, \"probe_movies_mapped\": movie_ids_val_final,\n","    \"probe_ratings_true\": ratings_val_true, \"N_users_active\": N_users_active,\n","    \"M_movies_active\": M_movies_active, \"rank_local\": RANK, \"lam_sq\": LAM_SQ,\n","    \"lam_bias\": LAM_BIAS, \"rng\": GLOBAL_RNG, \"init_scale\": INIT_SCALE_NON_CONVEX,\n","}\n","\n","# --- Run Non-Convex Solvers ---\n","if DATA_AVAILABLE and R_train_coo.nnz > 0 and N_users_active > 0 and M_movies_active > 0:\n","    # Euclidean GD (NEW)\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (Euclidean GD with Biases) ---\")\n","    try: all_results['Non-Convex (EucGD+Bias)'] = run_euclidean_gd(**solver_args, n_iters=N_ITERS_ALL, lr=1e-7) # Added call, specify LR\n","    except Exception as e: logger.error(f\"EucGD Failed: {e}\", exc_info=True); all_results['Non-Convex (EucGD+Bias)'] = {}\n","    # SVRG\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (SVRG Adaptation with Biases) ---\")\n","    try: all_results['Non-Convex (SVRG+Bias)'] = run_non_convex_svrg_with_biases(**solver_args, n_epochs=N_ITERS_ALL, inner_lr=INIT_LR_SVRG, batch_size=RSVRG_BATCH_SIZE, max_grad_norm=GRAD_CLIP_THRESHOLD)\n","    except Exception as e: logger.error(f\"SVRG Failed: {e}\", exc_info=True); all_results['Non-Convex (SVRG+Bias)'] = {}\n","    # ALS\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (ALS with Biases) ---\")\n","    try: all_results['Non-Convex (ALS+Bias)'] = run_als_with_biases(**solver_args, n_iters=N_ITERS_ALL, tol=ALS_TOL)\n","    except Exception as e: logger.error(f\"ALS Failed: {e}\", exc_info=True); all_results['Non-Convex (ALS+Bias)'] = {}\n","    # RGD\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (RGD with Biases) ---\")\n","    try: all_results['Non-Convex (RGD+Bias)'] = run_rgd_with_biases(**solver_args, n_iters=N_ITERS_ALL, lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA)\n","    except Exception as e: logger.error(f\"RGD Failed: {e}\", exc_info=True); all_results['Non-Convex (RGD+Bias)'] = {}\n","    # RAGD\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (RAGD with Biases) ---\")\n","    try: all_results['Non-Convex (RAGD+Bias)'] = run_ragd_with_biases(**solver_args, n_iters=N_ITERS_ALL, lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA, gamma=RAGD_GAMMA, mu=RAGD_MU, beta_ragd=RAGD_BETA)\n","    except Exception as e: logger.error(f\"RAGD Failed: {e}\", exc_info=True); all_results['Non-Convex (RAGD+Bias)'] = {}\n","    # Catalyst + Selected Inner Solver\n","    if RANK_MPI == 0: logger.info(f\"\\n--- Running Non-Convex Solver (Catalyst-{INNER_SOLVER.upper()} with Biases) ---\")\n","    try: all_results[f'Non-Convex (Catalyst+{INNER_SOLVER.upper()})'] = run_catalyst_stochastic(**solver_args, n_iters=N_ITERS_ALL, lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA, kappa_0=KAPPA_0, kappa_cvx=KAPPA_CVX, inner_T_epochs=CATALYST_INNER_T_EPOCHS, inner_S_epochs_base=CATALYST_INNER_S_EPOCHS_BASE, max_kappa_doublings=MAX_KAPPA_DOUBLINGS, inner_solver_type=INNER_SOLVER, inner_solver_lr=RSVRG_LR, inner_solver_bs=RSVRG_BATCH_SIZE)\n","    except Exception as e: logger.error(f\"Catalyst-{INNER_SOLVER.upper()} Failed: {e}\", exc_info=True); all_results[f'Non-Convex (Catalyst+{INNER_SOLVER.upper()})'] = {}\n","    # DANE\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Non-Convex Solver (DANE with Biases) ---\")\n","    try: all_results['Non-Convex (DANE+Bias)'] = run_dane_with_biases(**solver_args, n_iters=N_ITERS_ALL, lr_init=INIT_LR_RIEMANN, ls_beta=LS_BETA, ls_sigma=LS_SIGMA, kappa=DANE_KAPPA)\n","    except Exception as e: logger.error(f\"DANE Failed: {e}\", exc_info=True); all_results['Non-Convex (DANE+Bias)'] = {}\n","else:\n","    if RANK_MPI == 0: logger.warning(\"Skipping Non-Convex Solvers due to missing data or zero dimensions.\")\n","\n","# --- Run Convex Solver (Efficient Soft-Impute) ---\n","if DATA_AVAILABLE and R_train_coo_orig.nnz > 0 and N_users_active > 0 and M_movies_active > 0:\n","    if RANK_MPI == 0: logger.info(\"\\n--- Running Convex Solver (Efficient Soft-Impute) ---\")\n","    try:\n","        results_convex = run_soft_impute_efficient(\n","            R_train_coo_orig=R_train_coo_orig, # Use original ratings matrix\n","            probe_users_mapped=user_ids_val_final,\n","            probe_movies_mapped=movie_ids_val_final,\n","            probe_ratings_true=ratings_val_true, # Use validation ratings\n","            N_users_active=N_users_active,\n","            M_movies_active=M_movies_active,\n","            n_iters=N_ITERS_ALL, # Use N_ITERS_ALL for consistency\n","            lambda_reg=LAM, # Use LAM directly\n","            k_rank = CONVEX_RANK_K,\n","            tol=SOFT_IMPUTE_TOL,\n","            rng=GLOBAL_RNG\n","        )\n","        all_results['Convex (SoftImpute Eff.)'] = results_convex\n","    except Exception as e:\n","        logger.error(f\"Failed to run Efficient Soft-Impute Solver: {e}\", exc_info=True)\n","        all_results['Convex (SoftImpute Eff.)'] = {'loss': [], 'rmse': [], 'time': [], 'rank': []}\n","else:\n","    if RANK_MPI == 0: logger.warning(\"Skipping Convex Solver due to missing data or zero dimensions.\")\n","    all_results['Convex (SoftImpute Eff.)'] = {'loss': [], 'rmse': [], 'time': [], 'rank': []}\n","\n","\n","# --- Plotting Comparison ---\n","if RANK_MPI == 0:\n","    logger.info(\"\\n--- Generating Comparison Plots ---\")\n","    plt.style.use('seaborn-v0_8-whitegrid')\n","    fig, axes = plt.subplots(3, 2, figsize=(12, 11), sharex='col')\n","    fig.suptitle(\n","        f'MovieLens 1M ({RATING_LIMIT/1e6 if RATING_LIMIT else \"Full\"} M ratings subset), '\n","        f'Rank={RANK}, Outer iters={N_ITERS_ALL})',\n","        fontsize=14,\n","    )\n","\n","    # ---------- style dictionary (matches earlier section) ------------------\n","    styles = {\n","        'Non-Convex (SVRG+Bias)': dict(label=r'SVRG+Bias', style=('-',  'p'), alpha=.90, color='tab:purple'),\n","        'Non-Convex (ALS+Bias)': dict(label=r'ALS+Bias', style=('-',  'v'), alpha=.90, color='tab:brown'),\n","        'Non-Convex (RGD+Bias)': dict(label=r'RGD+Bias', style=('--', 'o'), alpha=.80, color='tab:blue'),\n","        'Non-Convex (RAGD+Bias)': dict(label=r'RAGD+Bias', style=('-.', 'D'), alpha=.80, color='tab:orange'),\n","        f'Non-Convex (Catalyst+{INNER_SOLVER.upper()})': dict(label=f'Catalyst+{INNER_SOLVER.upper()}', style=('-',  's'), alpha=.90, color='tab:red'),\n","        'Non-Convex (DANE+Bias)': dict(label=r'DANE+Bias', style=('-',  'x'), alpha=.80, color='tab:cyan'),\n","        'Non-Convex (EucGD+Bias)': dict(label=r'EucGD+Bias', style=(':',  '^'), alpha=.70, color='tab:green'),\n","        'Convex (SoftImpute Eff.)': dict(label=r'SoftImpute (Eff)', style=('-',  '*'), alpha=.90, color='tab:pink'),\n","    }\n","\n","    # ---------- helper for plotting one method ------------------------------\n","    def _plot(ax_iter, ax_time, data, meta):\n","        ls, mk = meta['style']\n","        kw = dict(linestyle=ls, marker=mk, markersize=3, alpha=meta['alpha'], color=meta.get('color', None))\n","        n_loss = len(data.get('loss', [])); n_grad = len(data.get('grad_norm', [])); n_rmse = len(data.get('rmse', [])); n_time = len(data.get('time', []))\n","        n = min(n_loss if n_loss > 0 else float('inf'), n_grad if n_grad > 0 else float('inf'), n_rmse if n_rmse > 0 else float('inf'), n_time if n_time > 0 else float('inf'))\n","        if n == float('inf') or n < 2: logger.warning(f\"  • insufficient points for {meta['label']}\"); return\n","\n","        it = np.arange(n)\n","        loss_vals = np.array(data.get('loss', [np.nan]*n)[:n]); grad_vals = np.array(data.get('grad_norm', [np.nan]*n)[:n])\n","        rmse_vals = np.array(data.get('rmse', [np.nan]*n)[:n]); time_vals = np.array(data.get('time', [np.nan]*n)[:n])\n","\n","        # Determine primary metric for grad plot (grad_norm, or gU_norm for SVRG)\n","        grad_metric = grad_vals\n","        if not np.any(np.isfinite(grad_metric)) and 'gU_norm' in data:\n","             grad_metric = np.array(data.get('gU_norm', [np.nan]*n)[:n])\n","\n","        loss_ok = np.isfinite(loss_vals); grad_ok = np.isfinite(grad_metric); rmse_ok = np.isfinite(rmse_vals); time_ok = np.isfinite(time_vals)\n","\n","        # iteration domain\n","        if np.any(loss_ok): ax_iter[0].semilogy(it[loss_ok], loss_vals[loss_ok], label=meta['label'], **kw)\n","        if np.any(grad_ok): ax_iter[1].semilogy(it[grad_ok], grad_metric[grad_ok], **kw)\n","        if np.any(rmse_ok): ax_iter[2].plot(it[rmse_ok], rmse_vals[rmse_ok], **kw)\n","\n","        # wall-clock domain\n","        if np.any(loss_ok & time_ok): ax_time[0].semilogy(time_vals[loss_ok & time_ok], loss_vals[loss_ok & time_ok], **kw)\n","        if np.any(grad_ok & time_ok): ax_time[1].semilogy(time_vals[grad_ok & time_ok], grad_metric[grad_ok & time_ok], **kw)\n","        if np.any(rmse_ok & time_ok): ax_time[2].plot(time_vals[rmse_ok & time_ok], rmse_vals[rmse_ok & time_ok], **kw)\n","\n","    # ---------- draw every available method ---------------------------------\n","    for m, d in all_results.items():\n","        if m in styles and d: # Check if history dict is not empty\n","            _plot(axes[:, 0], axes[:, 1], d, styles[m])\n","        else:\n","            logger.warning(f\"  • no style or no results for '{m}', skipped.\")\n","\n","    # labels / titles\n","    axes[0,0].set_ylabel('Objective'); axes[0,0].set_title('Loss vs Iterations')\n","    axes[1,0].set_ylabel(r'$\\|\\nabla\\|$'); axes[1,0].set_title('Grad-norm vs Iterations')\n","    axes[2,0].set_ylabel('Validation RMSE'); axes[2,0].set_xlabel('Iteration k'); axes[2,0].set_title('RMSE vs Iterations')\n","    axes[0,1].set_xscale('log'); axes[0,1].set_ylabel('Objective'); axes[0,1].set_title('Loss vs Wall-time')\n","    axes[1,1].set_xscale('log'); axes[1,1].set_ylabel(r'$\\|\\nabla\\|$'); axes[1,1].set_title('Grad-norm vs Wall-time')\n","    axes[2,1].set_xscale('log'); axes[2,1].set_ylabel('Validation RMSE'); axes[2,1].set_xlabel('Seconds'); axes[2,1].set_title('RMSE vs Wall-time')\n","\n","    for ax in axes.flatten():\n","        ax.grid(True, which='both', linestyle=':', linewidth=.5)\n","        handles, labels = ax.get_legend_handles_labels()\n","        if handles: ax.legend() # Only add legend if there are labeled artists\n","\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n","    plt.show()\n","\n","    # ---------- optional PCA trajectory plot --------------------------------\n","    if PCA_AVAILABLE and TRAJECTORY_CACHE is not None and len(TRAJECTORY_CACHE) >= 3:\n","        logger.info(\"\\n+++ Generating PCA Trajectory Plot +++\")\n","        try:\n","            traj_dim = TRAJECTORY_CACHE[0].size\n","            valid_traj = [t for t in TRAJECTORY_CACHE if isinstance(t, np.ndarray) and t.size == traj_dim]\n","            if len(valid_traj) >= 3:\n","                 pcs = PCA(n_components=2).fit_transform(np.vstack(valid_traj))\n","                 plt.figure(figsize=(4.5,4)); plt.plot(pcs[:,0], pcs[:,1], '-o', markersize=3)\n","                 plt.title('Optimisation Trajectory (PCA)'); plt.xlabel('PC1'); plt.ylabel('PC2')\n","                 plt.tight_layout(); plt.show()\n","            else: logger.warning(\"Not enough valid trajectory points for PCA plot.\")\n","        except Exception as e_pca: logger.error(f\"PCA Trajectory plot failed: {e_pca}\")\n","\n","\n","# --- Final Summary Table ---\n","if RANK_MPI == 0:\n","    logger.info(\"\\n--- Final Comparison Summary ---\")\n","    print(f\"{'Method':<30} | {'Final RMSE':<15} | {'Final Loss':<15} | {'Final Rank/GradNorm':<18} | {'Time (s)':<15}\")\n","    print(f\"{'-'*30}-|-{'-'*15}-|-{'-'*15}-|-{'-'*18}-|-{'-'*15}\")\n","    def get_last_finite(history, key):\n","        if not isinstance(history, dict): return np.nan\n","        data = history.get(key)\n","        if isinstance(data, (list, np.ndarray)) and len(data) > 0:\n","            arr = np.array(data); finite_vals = arr[np.isfinite(arr)]\n","            return finite_vals[-1] if finite_vals.size > 0 else np.nan\n","        return np.nan\n","    for label, history in all_results.items():\n","        if not history: print(f\"{label:<30} | {'FAILED':<15} | {'FAILED':<15} | {'N/A':<18} | {'N/A':<15}\"); continue\n","        final_rmse = get_last_finite(history, 'rmse')\n","        final_loss = get_last_finite(history, 'loss')\n","        final_time = get_last_finite(history, 'time')\n","        final_rank = get_last_finite(history, 'rank') if 'rank' in history else RANK\n","        final_grad_norm = get_last_finite(history, 'grad_norm') if 'grad_norm' in history else np.nan\n","        final_gU_norm = get_last_finite(history, 'gU_norm') if 'gU_norm' in history else np.nan\n","        rmse_str = f\"{final_rmse:.6f}\" if np.isfinite(final_rmse) else 'NaN'\n","        loss_str = f\"{final_loss:.6e}\" if np.isfinite(final_loss) and 'ALS' not in label and 'SoftImpute' not in label else 'N/A'\n","        rank_or_grad_str = 'N/A'\n","        if 'SoftImpute' in label: rank_or_grad_str = f\"Rank={int(final_rank)}\" if np.isfinite(final_rank) else 'N/A'\n","        elif 'grad_norm' in history and np.isfinite(final_grad_norm): rank_or_grad_str = f\"||G||={final_grad_norm:.2e}\"\n","        elif 'gU_norm' in history and np.isfinite(final_gU_norm): rank_or_grad_str = f\"||gU||={final_gU_norm:.2e}\"\n","        else: rank_or_grad_str = f\"Rank={RANK}\"\n","        time_str = f\"{final_time:.4f}\" if np.isfinite(final_time) else 'N/A'\n","        print(f\"{label:<30} | {rmse_str:<15} | {loss_str:<15} | {rank_or_grad_str:<18} | {time_str:<15}\")\n","    print(\"\\nComparison Complete.\")\n","\n","# --- ADDED Block 6-a: Run OT Demo (Rank 0 only) ---\n","# --- ADDED Block 6-a: Run OT Demo (Rank 0 only) ---\n","if RANK_MPI == 0 and OT_AVAILABLE:\n","    logger.info(\"\\n+++ Running OT Barycentre Demo +++\")\n","    try:\n","        ot_demo_results = run_barycentre_demo()\n","        # Optionally plot or process ot_demo_results\n","        plt.figure(figsize=(6, 4))\n","        plt.plot(ot_demo_results['grid'], ot_demo_results['sources'], '--', label='Sources')\n","        plt.plot(ot_demo_results['grid'], ot_demo_results['barycenter'], 'r-', label='Barycenter')\n","        plt.title('Wasserstein Barycenter Demo')\n","        plt.legend(); plt.tight_layout(); plt.show()\n","    except Exception as e_ot:\n","        logger.error(f\"OT Barycentre Demo failed: {e_ot}\")\n","\n","# === ADDED Block 6: PCA Trajectory Plot (Rank 0 only) ===\n","if RANK_MPI == 0 and PCA_AVAILABLE and len(TRAJECTORY_CACHE) >= 3:\n","    logger.info(\"\\n+++ Generating PCA Trajectory Plot +++\")\n","    try:\n","        # Ensure all trajectories have the same dimension (flattened U)\n","        traj_dim = TRAJECTORY_CACHE[0].size\n","        valid_traj = [t for t in TRAJECTORY_CACHE if t.size == traj_dim]\n","        if len(valid_traj) >= 3:\n","             pcs = PCA(n_components=2).fit_transform(np.vstack(valid_traj))\n","             plt.figure(figsize=(4.5,4)); plt.plot(pcs[:,0], pcs[:,1], '-o', markersize=3)\n","             plt.title('Optimisation Trajectory (PCA)'); plt.xlabel('PC1'); plt.ylabel('PC2')\n","             plt.tight_layout(); plt.show()\n","        else:\n","             logger.warning(\"Not enough valid trajectory points for PCA plot.\")\n","    except Exception as e_pca:\n","         logger.error(f\"PCA Trajectory plot failed: {e_pca}\")\n","\n","# === ADDED Block 7: Dump TeX skeleton to Drive (Rank 0 only) ===\n","if RANK_MPI == 0:\n","    TEX_PATH = Path(DATA_DIR_STR) / \"proofs.tex\" # Use Path object\n","    if TEX_PATH.parent.is_dir():\n","        logger.info(f\"\\n+++ Checking/Writing TeX Proof Skeleton to: {TEX_PATH} +++\")\n","        if not TEX_PATH.exists():\n","            try:\n","                with open(TEX_PATH, \"w\") as f: f.write(r\"\"\"...\"\"\") # TeX content omitted for brevity\n","                logger.info(f\"  Wrote TeX scaffold to {TEX_PATH}\")\n","            except IOError as e: logger.error(f\"  Error writing TeX file: {e}\")\n","        else: logger.info(f\"  TeX scaffold already exists at {TEX_PATH}, not overwritten.\")\n","    else: logger.warning(f\"  Parent directory for TeX file not found: {TEX_PATH.parent}\")\n","\n","# ============================================================================ #\n","# CELL 8: Plots & Dashboards (from long.txt) - Renumbered\n","# ============================================================================ #\n","if RANK_MPI == 0:\n","    logger.info(\"\\n+++ Cell 8: Plots & Dashboards +++\")\n","\n","    # ---------- helper ---------------------------------------------------- #\n","def _plot_metric(metric_key: str,\n","                 ylabel: str,\n","                 x_key: str = \"time\",\n","                 title: str | None = None,\n","                 logy: bool = False,\n","                 logx: bool = True,          # Default: log time axis\n","                 figsize=(8, 5)) -> None:\n","    plt.figure(figsize=figsize)\n","    has_data_to_plot = False\n","\n","    # style dictionary ----------------------------------------------------\n","    styles = {\n","        'Non-Convex (SVRG+Bias)':      dict(label='SVRG+Bias',      style=('-',  'p'), alpha=.90, color='tab:purple'),\n","        'Non-Convex (ALS+Bias)':       dict(label='ALS+Bias',       style=('-',  'v'), alpha=.90, color='tab:brown'),\n","        'Non-Convex (RGD+Bias)':       dict(label='RGD+Bias',       style=('--', 'o'), alpha=.80, color='tab:blue'),\n","        'Non-Convex (RAGD+Bias)':      dict(label='RAGD+Bias',      style=('-.', 'D'), alpha=.80, color='tab:orange'),\n","        f'Non-Convex (Catalyst+{INNER_SOLVER.upper()})':\n","                                       dict(label=f'Catalyst+{INNER_SOLVER.upper()}',\n","                                            style=('-',  's'), alpha=.90, color='tab:red'),\n","        'Non-Convex (DANE+Bias)':      dict(label='DANE+Bias',      style=('-',  'x'), alpha=.80, color='tab:cyan'),\n","        'Non-Convex (EucGD+Bias)':     dict(label='EucGD+Bias',     style=(':',  '^'), alpha=.70, color='tab:green'),\n","        'Convex (SoftImpute Eff.)':    dict(label='SoftImpute (Eff)',style=('-', '*'), alpha=.90, color='tab:pink'),\n","    }\n","\n","    # loop over solver results -------------------------------------------\n","    for name, res in all_results.items():\n","        y = res.get(metric_key, [])\n","        x = res.get(x_key, list(range(len(y)))) if x_key else list(range(len(y)))\n","\n","        if len(y) == 0:\n","            continue\n","\n","        x = np.asarray(x, dtype=float)\n","        y = np.asarray(y, dtype=float)\n","        valid = np.isfinite(x) & np.isfinite(y)\n","        x_plot, y_plot = x[valid], y[valid]\n","\n","        if x_plot.size == 0:\n","            logger.warning(f\"No finite data to plot for {name} – {metric_key}\")\n","            continue\n","\n","        style = styles.get(name, {})\n","        plt.plot(\n","            x_plot, y_plot,\n","            linestyle=style.get('style', ('-', 'o'))[0],\n","            marker=style.get('style', ('-', 'o'))[1],\n","            markersize=3,\n","            alpha=style.get('alpha', 0.8),\n","            color=style.get('color'),\n","            label=style.get('label', name)\n","        )\n","        has_data_to_plot = True\n","\n","    # axes / formatting ---------------------------------------------------\n","    plt.xlabel(\"wall-clock (s)\" if x_key == \"time\" else \"iteration\")\n","    plt.ylabel(ylabel)\n","    if logx:\n","        plt.xscale(\"log\")\n","    if logy:\n","        plt.yscale(\"log\")\n","    plt.title(title or f\"{ylabel} vs {'time' if x_key == 'time' else 'iteration'}\")\n","    if has_data_to_plot:\n","        plt.legend()\n","    plt.grid(alpha=.3, which='both', linestyle=':')\n","    plt.tight_layout()\n","    plt.show()\n","\n","    # ---------- Summary Table ----------\n","    logger.info(\"\\n--- Final Comparison Summary (Pandas) ---\")\n","    summary = []\n","    for name, res in all_results.items():\n","        if isinstance(res, dict) and res.get(\"rmse\"):\n","            best_rmse = min([v for v in res[\"rmse\"] if np.isfinite(v)], default=np.nan)\n","            final_rmse = get_last_finite(res, \"rmse\")\n","            final_time = get_last_finite(res, \"time\")\n","            summary.append({\"solver\": name, \"best RMSE\": best_rmse, \"final RMSE\": final_rmse, \"train time (s)\": final_time})\n","    if summary:\n","        summary_df = pd.DataFrame(summary).sort_values(\"best RMSE\")\n","        display(summary_df) # Use display for Colab/Jupyter\n","    else: logger.warning(\"No valid results to display in summary table.\")\n","\n","    # ---------- Save Figures ----------\n","    FIG_DIR = Path(DATA_DIR_STR) / \"figs\"\n","    try:\n","        FIG_DIR.mkdir(exist_ok=True, parents=True)\n","        logger.info(f\"Saving figures to {FIG_DIR}...\")\n","        for n, fig_num in enumerate(plt.get_fignums(), 1):\n","            plt.figure(fig_num)\n","            fig_path = FIG_DIR / f\"solver_plot_{n:02d}.png\"\n","            plt.savefig(fig_path, dpi=180, bbox_inches='tight')\n","            print(\"  saved →\", fig_path)\n","    except Exception as e_fig: logger.error(f\"Could not save figures: {e_fig}\")\n","\n","    print(\"\\n✅ All comparisons finished.\")\n","\n","# --- ADDED Block 6-a: Run OT Demo (Rank 0 only) ---\n","if RANK_MPI == 0 and OT_AVAILABLE:\n","    logger.info(\"\\n+++ Running OT Barycentre Demo +++\")\n","    try:\n","        if 'run_barycentre_demo' in globals():\n","            ot_demo_results = run_barycentre_demo()\n","            plt.figure(figsize=(6, 4))\n","            plt.plot(ot_demo_results['grid'], ot_demo_results['sources'], '--', label='Sources')\n","            plt.plot(ot_demo_results['grid'], ot_demo_results['barycenter'], 'r-', label='Barycenter')\n","            plt.title('Wasserstein Barycenter Demo'); plt.legend(); plt.tight_layout(); plt.show()\n","        else: logger.warning(\"run_barycentre_demo function not defined. Skipping OT demo.\")\n","    except Exception as e_ot: logger.error(f\"OT Barycentre Demo failed: {e_ot}\")\n","\n","# === ADDED Block 6: PCA Trajectory Plot (Rank 0 only) ===\n","if RANK_MPI == 0 and PCA_AVAILABLE and TRAJECTORY_CACHE is not None and len(TRAJECTORY_CACHE) >= 3:\n","    logger.info(\"\\n+++ Generating PCA Trajectory Plot +++\")\n","    try:\n","        traj_dim = TRAJECTORY_CACHE[0].size\n","        valid_traj = [t for t in TRAJECTORY_CACHE if isinstance(t, np.ndarray) and t.size == traj_dim]\n","        if len(valid_traj) >= 3:\n","             pcs = PCA(n_components=2).fit_transform(np.vstack(valid_traj))\n","             plt.figure(figsize=(4.5,4)); plt.plot(pcs[:,0], pcs[:,1], '-o', markersize=3)\n","             plt.title('Optimisation Trajectory (PCA)'); plt.xlabel('PC1'); plt.ylabel('PC2')\n","             plt.tight_layout(); plt.show()\n","        else: logger.warning(\"Not enough valid trajectory points for PCA plot.\")\n","    except Exception as e_pca: logger.error(f\"PCA Trajectory plot failed: {e_pca}\")\n","\n"]}],"metadata":{"accelerator":"TPU","colab":{"gpuType":"V28","machine_shape":"hm","provenance":[{"file_id":"10BctdzbFIEWfv0Jxl9wy6p-GRUab7ODN","timestamp":1746505931825},{"file_id":"1hNPd3CUP0GXjglnUO6xSGf7SnWl_d90S","timestamp":1746393693404}]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}